1
00:00:00,150 --> 00:00:04,050
我们回想以下 我们是如何定义排名函数的

2
00:00:04,050 --> 00:00:05,610
我们说过 要有一个时间步骤

3
00:00:05,610 --> 00:00:07,540
我们将一直按步骤执行

4
00:00:07,540 --> 00:00:10,220
来获得更准确的排名 但我们要初始化

5
00:00:10,220 --> 00:00:14,850
每个排名为 1 除以页数 之前我称之为大写 N

6
00:00:14,850 --> 00:00:19,820
现在我要使用 npages 作为一个更加 Pythonic (Python 风格) 的变量名称

7
00:00:20,930 --> 00:00:25,700
我们在 t 步骤 更新排名 通过添加

8
00:00:25,700 --> 00:00:29,770
随机浏览者 重新开始和随机选择

9
00:00:29,770 --> 00:00:32,500
该页面的概率 所以 这里是 1-d

10
00:00:32,500 --> 00:00:35,580
是重新开始的概率 除以 npages

11
00:00:35,580 --> 00:00:38,090
即页面数量 记住 d

12
00:00:38,090 --> 00:00:41,160
是我们的阻尼常数 我们决定 d 为 0.8

13
00:00:41,160 --> 00:00:44,160
这就是阻尼常数 我们将这些累加到

14
00:00:44,160 --> 00:00:50,710
我们得到的链接到此 URL 的所有页面的排名总和

15
00:00:50,710 --> 00:00:55,100
我们加上之前迭代的 d 倍 所以

16
00:00:55,100 --> 00:00:58,370
它将在该页面的步骤 t-1 的 d 次排名

17
00:00:58,370 --> 00:01:01,940
但是我们要将其除以

18
00:01:01,940 --> 00:01:05,080
p 的外链数量 所以 它开始

19
00:01:05,080 --> 00:01:07,270
看起来更像 Python 代码了 在转化为

20
00:01:07,270 --> 00:01:09,970
Python 代码之前 我们还要将其简化一点

21
00:01:09,970 --> 00:01:12,000
我们要做的第一件 来简化它的事情是

22
00:01:12,000 --> 00:01:16,960
观察到 我们有这个 t 参数

23
00:01:16,960 --> 00:01:19,990
但是我们只是需要使用上一个 所以我们

24
00:01:19,990 --> 00:01:22,870
其实不需要跟踪所有不同 t 值

25
00:01:22,870 --> 00:01:25,210
的 rank 值 我们只需要

26
00:01:25,210 --> 00:01:28,650
跟踪前一个 当我们做 Fibonacci 时 我们

27
00:01:28,650 --> 00:01:31,730
跟踪当前和下一个变量 这使我们

28
00:01:31,730 --> 00:01:34,970
跟踪前一个和前一个的前一个 Fibonacci 数

29
00:01:34,970 --> 00:01:37,980
我们对排名的想法是类似的

30
00:01:37,980 --> 00:01:42,360
所以 我们将使用变量 ranks 来跟踪

31
00:01:42,360 --> 00:01:45,040
当前的排名 当我们计算新的排名时

32
00:01:45,040 --> 00:01:48,880
我们将使用变量 newranks 所以 我们将

33
00:01:48,880 --> 00:01:53,720
使用 ranks 对应步骤 t-1 时的排名

34
00:01:53,720 --> 00:01:56,670
也就是上一次迭代的排名

35
00:01:56,670 --> 00:01:59,520
并且 我们会有一个变量 newranks 其表示

36
00:01:59,520 --> 00:02:02,260
t 步骤时的排名 我们需要这两个变量

37
00:02:02,260 --> 00:02:05,260
的原因是 当我们更新每个页面

38
00:02:05,260 --> 00:02:07,720
的排名 我们遍历这些页面

39
00:02:07,720 --> 00:02:11,860
重新计算其排名 我们不能失去前一个 我们

40
00:02:11,860 --> 00:02:14,490
仍然需要在该页面的上一步获得排名

41
00:02:14,490 --> 00:02:17,790
如果我们使用这一次我们得到的排名

42
00:02:17,790 --> 00:02:19,950
就会扭曲结果 这将意味着

43
00:02:19,950 --> 00:02:23,810
我们更新排名的顺序会改变结果 所以我们

44
00:02:23,810 --> 00:02:26,210
不希望结果依赖于我们浏览页面的顺序

45
00:02:26,210 --> 00:02:28,950
这就是为什么我们需要跟踪

46
00:02:28,950 --> 00:02:33,010
的两个先前的值 分别对应

47
00:02:33,010 --> 00:02:36,250
t-1 时的排名和新排名 一旦我们

48
00:02:36,250 --> 00:02:38,220
做完这些 我们就不再需要 t 参数了

49
00:02:38,220 --> 00:02:41,440
我们将要做的是改变这个排名

50
00:02:41,440 --> 00:02:44,390
步骤 t 的排名将是 newranks 的值

51
00:02:44,390 --> 00:02:47,130
而 t-1 步骤的排名

52
00:02:47,130 --> 00:02:50,560
是 ranks 的值 另一个

53
00:02:50,560 --> 00:02:54,720
我在这里做出的改动是 之前这里是小括号

54
00:02:54,720 --> 00:02:58,480
我已经把它们改成了方括号

55
00:02:58,480 --> 00:03:01,220
方括号应该会给你一个想法 这可能

56
00:03:01,220 --> 00:03:05,390
是我们索引的数据结构 这个想法是对的 我们

57
00:03:05,390 --> 00:03:07,820
想索引数据结构 我们想要由

58
00:03:07,820 --> 00:03:12,540
我们正在查找的 URL 来索引 而 Python 字典

59
00:03:12,540 --> 00:03:14,630
提供了一个很好的方式来做到这一点 最后

60
00:03:14,630 --> 00:03:18,090
这将是一个 Python 字典 这正是我们想要的

61
00:03:18,090 --> 00:03:20,450
所以 我想我们已经准备好开始看代码了

62
00:03:20,450 --> 00:03:23,870
我们已经写了这个公式 它仍然是数学和 Python 的混合

63
00:03:23,870 --> 00:03:26,820
但是我们将把它转化为用于计算页面排名的代码
