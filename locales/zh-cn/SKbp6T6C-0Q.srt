1
00:00:00,160 --> 00:00:02,860
我们已经看到 只看首字母的初始版本

2
00:00:02,860 --> 00:00:06,200
并不能很好的工作 没有充分利用桶

3
00:00:06,200 --> 00:00:09,390
并且关键词没有很好的分布 所以现在我们

4
00:00:09,390 --> 00:00:11,310
将考虑如何构建一个更好的哈希函数

5
00:00:11,310 --> 00:00:14,360
我们想要和之前相同的属性

6
00:00:14,360 --> 00:00:17,160
它是一个有两个输入的函数

7
00:00:17,160 --> 00:00:20,630
这两个输入分别是 keyword ——

8
00:00:20,630 --> 00:00:24,940
一个字符串 还有 buckets 的数目 —— 一个数字

9
00:00:24,940 --> 00:00:28,040
这是两个输入 而输出是

10
00:00:28,040 --> 00:00:31,700
哈希值 它的范围从 0 到

11
00:00:31,700 --> 00:00:35,120
桶数目 - 1 我们的目标是

12
00:00:35,120 --> 00:00:39,030
希望其良好的分布 所以我们可以有

13
00:00:39,030 --> 00:00:41,610
我们想要的任意桶数目 关键词会

14
00:00:41,610 --> 00:00:44,440
在桶之间均匀分布 每次我们同一个

15
00:00:44,440 --> 00:00:47,010
关键词进行哈希 我们将会得到相同的桶 这样我们将

16
00:00:47,010 --> 00:00:50,210
很快知道去哪里寻找它 为了做的比

17
00:00:50,210 --> 00:00:52,240
之前更好 我们需要查看更多

18
00:00:52,240 --> 00:00:54,520
而不是只看关键词中的一个字母 如果我们只关注

19
00:00:54,520 --> 00:00:58,410
首字母 我们将不会比之前有限数目的桶的

20
00:00:58,410 --> 00:01:00,790
坏分布做得更好 所以我们想做的是

21
00:01:00,790 --> 00:01:03,070
去关注关键词的所有字母

22
00:01:03,070 --> 00:01:06,796
不仅仅是首字母 我们将根据所有的字母 确定它们

23
00:01:06,796 --> 00:01:10,877
合适的桶 我们用列表看一下 如果我们有一列元素

24
00:01:10,877 --> 00:01:15,865
我们可以像这样使用 for 循环结构

25
00:01:15,865 --> 00:01:19,227
遍历其元素 这会遍历 p 中的

26
00:01:19,227 --> 00:01:22,314
每一个元素 把它赋值给变量 e

27
00:01:22,314 --> 00:01:25,370
对 p 的每个元素执行程序块中的代码

28
00:01:25,370 --> 00:01:28,360
我们可以对字符串做一些类似的事情 所以如果我们有

29
00:01:28,360 --> 00:01:30,830
字符串 s 我们可以使用相同的结构

30
00:01:30,830 --> 00:01:33,966
去遍历 s 中的字符 所以每次循环的执行

31
00:01:33,966 --> 00:01:36,976
都会按字符串中的字符顺序把相应的

32
00:01:36,976 --> 00:01:41,482
单字符赋值给变量 c

33
00:01:41,482 --> 00:01:43,407
所以它首先拥有值 a 然后

34
00:01:43,407 --> 00:01:45,860
是值 b 然后是值 c 然后是 d

35
00:01:45,860 --> 00:01:47,472
所以这给我们了一种方法去遍历

36
00:01:47,472 --> 00:01:51,100
字符串里的所有元素 并且如果你还记得我们如何把

37
00:01:51,100 --> 00:01:56,760
单一字母映射成数字和模运算 那么

38
00:01:56,760 --> 00:01:58,970
我认为你了解的已经足够定义一个更好的哈希函数

39
00:01:58,970 --> 00:02:01,740
对于这次练习 你的任务是定义

40
00:02:01,740 --> 00:02:06,650
一个像这样的 hash_string 函数 它用关键词

41
00:02:06,650 --> 00:02:10,850
和桶数目作为输入 然后输出一个数字 来确认

42
00:02:10,850 --> 00:02:13,670
关键词属于哪个桶 但是要取代只使用关键词

43
00:02:13,670 --> 00:02:16,301
的首字母 它将使用所有字母 并且产出

44
00:02:16,301 --> 00:02:18,070
一个单独的数字作为输出

45
00:02:18,070 --> 00:02:21,060
代表关键词所属的桶

46
00:02:21,060 --> 00:02:22,740
你的目标是实现一种方式 其依赖于

47
00:02:22,740 --> 00:02:26,070
字符串中的所有字母 而不仅仅是第一个

48
00:02:26,070 --> 00:02:28,100
有很多方式去实现它 所以我们将

49
00:02:28,100 --> 00:02:31,790
明确你到底要做什么 我们要做的是实现

50
00:02:31,790 --> 00:02:35,090
一个根据关键词所有字母 进行哈希处理的函数

51
00:02:35,090 --> 00:02:37,950
我们可以考虑用模运算 如果我们

52
00:02:37,950 --> 00:02:41,070
有一个圆代表桶的数目

53
00:02:41,070 --> 00:02:44,555
所以它是从 0 到 桶数目 - 1

54
00:02:44,555 --> 00:02:46,970
但是我们想对每一个字母这样做 我们将

55
00:02:46,970 --> 00:02:50,140
从 0 开始 对于字符串的每个字母

56
00:02:50,140 --> 00:02:54,730
我们结合字符对应的 ord 值 沿着圆圈走一段距离

57
00:02:54,730 --> 00:02:56,820
然后我们将持续进行 所以对每个字母

58
00:02:56,820 --> 00:02:59,170
我们将沿着圆圈前进 圆圈

59
00:02:59,170 --> 00:03:01,353
根据桶数目 可以是任何大小

60
00:03:01,353 --> 00:03:05,700
我们将沿着圆圈前进 对每个字母进行

61
00:03:05,700 --> 00:03:09,170
模运算 我们保持前进 我们可能

62
00:03:09,170 --> 00:03:10,670
环绕很多很多次 如果这是一个很长的词

63
00:03:10,670 --> 00:03:14,355
无论我们结束在哪里 那个位置就是

64
00:03:14,355 --> 00:03:19,067
我们要使用的桶 让我们假设那就是位置 27

65
00:03:19,067 --> 00:03:21,995
我们知道它在哪 所以这就是思路 然后

66
00:03:21,995 --> 00:03:23,638
我会给你一些例子

67
00:03:23,638 --> 00:03:25,956
以便你了解 你是否是按照正确的方式实现的

68
00:03:25,956 --> 00:03:29,544
假设我们有一个字符串

69
00:03:29,544 --> 00:03:33,430
单字母 a 还有 12 个桶 那么

70
00:03:33,430 --> 00:03:35,710
在这种情况下 我们有 12 个桶 所以

71
00:03:35,710 --> 00:03:39,046
我们在这里不会有 27 这将变成

72
00:03:39,046 --> 00:03:47,355
最后一个桶是 11 ord('a') 的值是 97 所以对于 a 我们将要

73
00:03:47,355 --> 00:03:52,602
做的是 环绕这个圆圈 8 次

74
00:03:52,602 --> 00:03:58,008
因为 97 等于 12 * 8 + 1

75
00:03:58,008 --> 00:04:04,040
因为 97 等于 12 * 8 + 1 你不必真的去

76
00:04:04,040 --> 00:04:07,360
绕圈 如果你使用模运算 就会获得结果

77
00:04:07,360 --> 00:04:12,424
所以 a 的哈希值在桶 1 处 来看另一个

78
00:04:12,424 --> 00:04:15,574
例子 如果我们要得到字母 b 的

79
00:04:15,574 --> 00:04:18,949
哈希值 同样也是 12 个桶 那么

80
00:04:18,949 --> 00:04:21,949
也将要环绕圆圈 8 次

81
00:04:21,949 --> 00:04:24,837
因为 b 的 ord 值是 98 但是它的

82
00:04:24,837 --> 00:04:27,996
哈希值在桶 2 因为 98 = 96 + 2

83
00:04:27,996 --> 00:04:31,660
所以会在桶 2 结束

84
00:04:31,660 --> 00:04:34,320
如果我们改变桶的数目 结果会不同

85
00:04:34,320 --> 00:04:37,430
那么让我们假设 如果桶的数目是 13 而不是 12

86
00:04:37,430 --> 00:04:42,190
我们尝试调用 hash_string 函数　

87
00:04:42,190 --> 00:04:47,250
并传入 a 和桶数目 13 这次会在

88
00:04:47,250 --> 00:04:52,180
桶 6 结束 结果是 6 的原因是

89
00:04:52,180 --> 00:04:57,080
97 = 13 * 7 + 6

90
00:04:57,080 --> 00:05:02,490
所以哈希表的大小很重要 以及字符串

91
00:05:02,490 --> 00:05:04,877
我们不想它只对单个字母有用 对于单个

92
00:05:04,877 --> 00:05:07,900
字母我们得到了和之前定义一样的东西

93
00:05:07,900 --> 00:05:11,020
真正有趣的是多个字母的情况

94
00:05:11,020 --> 00:05:14,460
所以让我们看一些这样的例子

95
00:05:14,460 --> 00:05:17,360
这样你可以看到区别 在我们将要

96
00:05:17,360 --> 00:05:19,960
看到的 hash_string 和我们之前的 bad_hash_string 之间

97
00:05:19,960 --> 00:05:23,870
就在与一旦我们有了更长的字符串 所以假设我们

98
00:05:23,870 --> 00:05:27,870
有字符串 au a 的 ord 值是 97

99
00:05:27,870 --> 00:05:34,606
我们环绕圆圈 在位置一结束 u 的 ord 值

100
00:05:34,606 --> 00:05:41,607
可以告诉你 是 117 当我们把两个值加在一起 得到 214

101
00:05:42,850 --> 00:05:48,470
然后对桶数目 12 取模后 我们得到了 10

102
00:05:48,470 --> 00:05:53,090
所以两个字符的字符串没在 a 之前结束的

103
00:05:53,090 --> 00:05:55,471
位置 1 它在桶 10 结束

104
00:05:55,471 --> 00:05:59,293
下一个例子 这次我们不会深入细节了

105
00:05:59,293 --> 00:06:01,867
但是你能够测试

106
00:06:01,867 --> 00:06:05,611
你的结果是否正确 如果你尝试字符串 udacity

107
00:06:05,611 --> 00:06:08,229I
它会在什么位置结束 对不起

108
00:06:08,229 --> 00:06:11,804
我忘记输入长度了 这是十分重要的

109
00:06:11,804 --> 00:06:14,339
hash_string 函数需要两个输入参数 字符串和

110
00:06:14,339 --> 00:06:18,482
桶数目都很重要 所以这里我们假设

111
00:06:18,482 --> 00:06:24,094
有 12 个桶 这里我们将再一次用这 12 个桶 结果应该是

112
00:06:24,094 --> 00:06:26,919
11 所以看看你是否可以定义一个 hash_string 函数可以

113
00:06:26,919 --> 00:06:29,880
实现这些 我们需要两个输入参数 并输出一个

114
00:06:29,880 --> 00:06:32,830
代表关键词所在桶位置的数字
