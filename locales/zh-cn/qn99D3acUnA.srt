1
00:00:00,130 --> 00:00:03,370
答案是 除了第一个 其他选项都是正确的

2
00:00:03,370 --> 00:00:06,030
第一个不正确的原因是

3
00:00:06,030 --> 00:00:08,220
真的不用花费太长时间来计算 我们只需要

4
00:00:08,220 --> 00:00:11,460
查看一个字母 然后做一个简单的模运算

5
00:00:11,460 --> 00:00:14,710
这是非常高效的 但是其他三个原因确实是正确的

6
00:00:14,710 --> 00:00:17,960
我们将会逐一介绍发生了什么

7
00:00:17,960 --> 00:00:21,430
通过在 Python 解释器中查看如何评估

8
00:00:21,430 --> 00:00:25,500
第一个正确的原因是 对于一种关键词输入

9
00:00:25,500 --> 00:00:28,350
它会产生错误 当我们在写代码的时候应当考虑

10
00:00:28,350 --> 00:00:31,880
对所有可能的输入 它是否都是有效的

11
00:00:31,880 --> 00:00:35,230
通常我们最容易忽视的就是边界情况

12
00:00:35,230 --> 00:00:38,770
一个字符串很有可能是一个空字符串

13
00:00:38,770 --> 00:00:42,110
如果我们传入一个空字符串

14
00:00:42,110 --> 00:00:44,990
当然这是有效的 但是当我们尝试

15
00:00:44,990 --> 00:00:48,200
用 0 索引的时候 这会是一个错误 让我们看看

16
00:00:48,200 --> 00:00:51,020
当我们在 Python 终端尝试这样做会发生什么

17
00:00:51,020 --> 00:00:56,240
我们将调用 bad_hash_string 传入空字符串

18
00:00:56,240 --> 00:00:59,250
作为关键词 这是一个完全有效的字符串 假设有

19
00:00:59,250 --> 00:01:01,530
一百个桶 然后我们确实得到一个错误

20
00:01:01,530 --> 00:01:03,340
我们得到的错误是 索引超出范围

21
00:01:03,340 --> 00:01:06,690
因为我们尝试访问位置 0 所在的字符

22
00:01:06,690 --> 00:01:09,640
但是在这个空字符串里位置 0 不存在任何字符

23
00:01:09,640 --> 00:01:13,200
为了理解剩下两个答案 我已经

24
00:01:13,200 --> 00:01:16,720
定义好了一个 test_hash_function 函数 它有三个输入

25
00:01:16,720 --> 00:01:19,410
第一个输入是一个函数 我们可以传递函数

26
00:01:19,410 --> 00:01:22,400
像传其它值一样 这里我们传的函数是

27
00:01:22,400 --> 00:01:25,430
我们之前定义的 bad_hash_string 函数 但是也可以

28
00:01:25,430 --> 00:01:28,780
用它来测试其它哈希函数 这点我们之后会看到 然后我们将传入

29
00:01:28,780 --> 00:01:31,730
一个键列表 其中是用于哈希表的关键词

30
00:01:31,730 --> 00:01:34,000
最后我们传递了长度参数 即桶的数目

31
00:01:34,000 --> 00:01:37,760
在 test_hash_function 里所做的是 我们将

32
00:01:37,760 --> 00:01:41,710
每个桶被使用的次数列表作为结果

33
00:01:41,710 --> 00:01:46,410
它们最开始都是 0 所以我们将其初始化为 0 * size

34
00:01:46,410 --> 00:01:49,820
我们将用 keys_used 作为

35
00:01:49,820 --> 00:01:52,430
已经被使用的关键词的列表 我们不想

36
00:01:52,430 --> 00:01:55,490
对重复的关键词计数 所以现在我们将

37
00:01:55,490 --> 00:01:57,730
迭代 keys 我们将校验一个关键词是否

38
00:01:57,730 --> 00:02:01,140
已被使用 如果还未被使用 那么

39
00:02:01,140 --> 00:02:04,340
我们将调用哈希函数来算出

40
00:02:04,340 --> 00:02:06,870
这个 key 应该哈希到哪里 如果我们传入

41
00:02:06,870 --> 00:02:08,910
bad_hash_string 那么这里的函数就会是它

42
00:02:08,910 --> 00:02:11,330
我们调用这个函数 传入一个关键词

43
00:02:11,330 --> 00:02:13,960
和桶的数目 我们把结果存在

44
00:02:13,960 --> 00:02:18,250
变量 hv 内 我们将会给

45
00:02:18,250 --> 00:02:21,300
results[hv] 的值增加 1

46
00:02:21,300 --> 00:02:24,510
这里是一个简写语法 与以下写法的

47
00:02:24,510 --> 00:02:28,880
含义一样 对 results[hv] 进行新的赋值

48
00:02:28,880 --> 00:02:32,460
当前 results[hv] 的值加上 1

49
00:02:32,460 --> 00:02:37,340
之后我们把这个刚才使用过的

50
00:02:37,340 --> 00:02:39,340
关键词加到 keys_used 里

51
00:02:39,340 --> 00:02:41,790
我们不会再次使用它 这与我们

52
00:02:41,790 --> 00:02:44,430
在网络爬虫里所做的类似 为了避免

53
00:02:44,430 --> 00:02:46,694
抓取相同的网页多次 最后我们返回了结果

54
00:02:46,694 --> 00:02:49,585
现在我们所拥有的 test_hash_function 函数的

55
00:02:49,585 --> 00:02:54,020
执行结果 是一个列表 其中的值为数字

56
00:02:54,020 --> 00:02:57,690
代表有多少个 key 哈希到

57
00:02:57,690 --> 00:03:00,950
该桶中 现在让我们尝试

58
00:03:00,950 --> 00:03:04,550
使用 bad_hash_string 函数来看一个例子 为了测试

59
00:03:04,550 --> 00:03:07,190
我们的哈希函数 我们需要一些文本

60
00:03:07,190 --> 00:03:09,660
这些文本可以代表我们将要在

61
00:03:09,660 --> 00:03:11,210
哈希表中使用的关键词

62
00:03:11,210 --> 00:03:14,610
我选了这一个 也许有代表性

63
00:03:14,610 --> 00:03:18,850
也许没有 这是文本链接

64
00:03:18,850 --> 00:03:22,750
是古腾堡的文本 —— 福尔摩斯的冒险

65
00:03:22,750 --> 00:03:28,710
你可以从滚动条看出 它十分长 这里是

66
00:03:28,710 --> 00:03:35,096
所有的文本 我们将用 getpage 得到所用的文字

67
00:03:35,096 --> 00:03:38,368
我们将把文本分离出单词

68
00:03:38,368 --> 00:03:40,272
像我们在爬虫那做的一样 我们将其

69
00:03:40,272 --> 00:03:42,660
储存在变量 words 中 可以看到

70
00:03:42,660 --> 00:03:47,860
长度超过 100,000 现在它们

71
00:03:47,860 --> 00:03:49,780
并不是唯一的 所以我们的哈希表

72
00:03:49,780 --> 00:03:52,610
条目的数量会较小一些 但是让我们看看

73
00:03:52,610 --> 00:03:55,430
这些文字是如何分布的 我们会使用

74
00:03:55,430 --> 00:03:58,440
我们定义的 test_hash_function

75
00:03:58,440 --> 00:04:01,540
传入 bad_hash_string 还有

76
00:04:01,540 --> 00:04:04,650
我们从福尔摩斯的冒险得到的文字 我们将选择 现在

77
00:04:04,650 --> 00:04:08,060
我们将 size 定为 12 肯定太小了 但是这会给

78
00:04:08,060 --> 00:04:10,030
我们一个关于桶数目很小时 分布是如何进行的

79
00:04:10,030 --> 00:04:12,960
直观感受 现在我们得到了结果

80
00:04:12,960 --> 00:04:16,459
让我们看看数目的分布

81
00:04:16,459 --> 00:04:20,260
你可以看到 我们有 12 个条目 对应的是

82
00:04:20,260 --> 00:04:22,560
桶的数目 它们差别很大

83
00:04:22,560 --> 00:04:27,580
最小的仅有 754 个元素

84
00:04:27,580 --> 00:04:30,140
而最大的超过了 2000 所以

85
00:04:30,140 --> 00:04:33,210
最大的几乎是最小的三倍

86
00:04:33,210 --> 00:04:35,440
如果我们的哈希函数是好的

87
00:04:35,440 --> 00:04:37,800
我们希望它们是大约相同的大小

88
00:04:37,800 --> 00:04:41,230
这是图形的展示 我们有 12 个桶

89
00:04:41,230 --> 00:04:44,730
红色的这些 太满了 而蓝色的这些

90
00:04:44,730 --> 00:04:47,510
又不够满 我们期望的是一个

91
00:04:47,510 --> 00:04:51,420
相当平坦的图 在桶中平均分配所有的词
