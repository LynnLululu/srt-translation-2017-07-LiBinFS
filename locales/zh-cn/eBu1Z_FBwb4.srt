1
00:00:00,420 --> 00:00:04,130
我们将要定义 fibonacci 所以这里

2
00:00:04,130 --> 00:00:07,360
是我们的定义 让我们尝试运行 那么

3
00:00:07,360 --> 00:00:10,850
我们首先打印一下 fibonacci(0)

4
00:00:10,850 --> 00:00:14,094
我们应该得到 0 确实如此 我们

5
00:00:14,094 --> 00:00:19,870
尝试 fibonacci(1) 我们得到 1 我们已经看到两个基本情况 现在

6
00:00:19,870 --> 00:00:25,598
我们尝试 fibonacci(2) 我们应该得到的是 fibonacci(1) 也就是 1

7
00:00:25,598 --> 00:00:30,290
加上  fibonacci(2-2) 也就是 fibonacci(0) 即 0 的结果

8
00:00:30,290 --> 00:00:35,128
因此 我们应该再得到 1 确实如此 现在

9
00:00:35,128 --> 00:00:40,810
让我们试着打印 fibonacci(3) 我们得到 2

10
00:00:40,810 --> 00:00:45,690
如果我们打印 fibonacci(4) 我们应该

11
00:00:45,690 --> 00:00:50,820
得到 1 + 2 也就是 3  正是我们得到的 如果我们尝试 5

12
00:00:50,820 --> 00:00:59,950
我们应该得到 2 + 3 就是 5 然后让我们尝试更大一点的数

13
00:01:02,410 --> 00:01:06,550
让我们试试 fibonacci(10) 我们得到了55 我们将尝试

14
00:01:08,890 --> 00:01:15,240
fibonacci(25) 我们先尝试一下 fibonacci(24) 对于月份计数来说 这将是

15
00:01:15,240 --> 00:01:22,190
兔子两年的数量 我们得到 46,000 让我们试试 3 年

16
00:01:22,190 --> 00:01:26,230
我们的程序超时 所以我

17
00:01:26,230 --> 00:01:28,750
想要在 Python 解释器中尽快尝试运行

18
00:01:28,750 --> 00:01:30,180
看看我们能否处理再稍微大一点的数

19
00:01:31,180 --> 00:01:34,330
但是 解决 fibonacci 消耗的时间

20
00:01:34,330 --> 00:01:38,210
在这种方式下会很长 原因是

21
00:01:38,210 --> 00:01:40,010
因为我们在做很多很多的

22
00:01:40,010 --> 00:01:42,830
冗余计算 所以如果我们看看

23
00:01:42,830 --> 00:01:46,620
我们代码在做的事情 每次我们调用

24
00:01:46,620 --> 00:01:49,960
fibonacci(n) 的同时 我们会调用 fibonacci(n-1)

25
00:01:49,960 --> 00:01:52,680
而且 我们会调用 fibonacci(n-2)

26
00:01:52,680 --> 00:01:56,090
那么我们开始了 我们调用 fibonacci(36)

27
00:01:56,090 --> 00:01:59,520
也就是解释器没有完成的那个例子

28
00:01:59,520 --> 00:02:02,250
然后 我们将得到的是

29
00:02:02,250 --> 00:02:06,980
被分解成调用 fibonacci(35) 加上

30
00:02:06,980 --> 00:02:09,008
我们调用 fibonacci(34) 获得的结果

31
00:02:09,008 --> 00:02:11,970
它们中的每一个都是另一次对

32
00:02:11,970 --> 00:02:15,180
fibonacci 的调用 所以调用 fibonacci(35)

33
00:02:15,180 --> 00:02:19,080
将被分解成 调用 fibonacci(34)

34
00:02:19,080 --> 00:02:24,960
加上我们调用 fibonacci(33) 得到的结果 然后当我们处理

35
00:02:24,960 --> 00:02:28,340
这里的 fibonacci(34) 好吧 那将变成

36
00:02:28,340 --> 00:02:32,590
调用 fibonacci(33) 加上 fibonacci(32) 的结果

37
00:02:32,590 --> 00:02:35,570
我们在这里要做很多很多很多的计算

38
00:02:35,570 --> 00:02:38,670
而且我们还没能向下接近到 fibo(1)

39
00:02:38,670 --> 00:02:40,840
或 fibo(0) 而这是我们唯一可以

40
00:02:40,840 --> 00:02:43,030
停下来的地方 如果我们看一下

41
00:02:43,030 --> 00:02:46,780
我们需要评估的次数 fibo(32) 让我们挑

42
00:02:46,780 --> 00:02:50,440
这个 所以 fibonacci(32) 那么我们需要评估

43
00:02:50,440 --> 00:02:55,130
fibonacci(32) 1、2、3、4、5次 我们需要评估

44
00:02:55,130 --> 00:03:01,280
fibonacci(33) 的次数为1、2、3次

45
00:03:01,280 --> 00:03:04,875
我们需要评估 fibonacci(34) 的次数

46
00:03:04,875 --> 00:03:10,860
是 2 次 我们需要评估 fibonacci(35) 的次数

47
00:03:10,860 --> 00:03:15,340
是 1 次 然后我们需要评估 fibonacci(36) 的次数为 1 次

48
00:03:15,340 --> 00:03:19,250
所以 也许你可以在这里看到一个模式

49
00:03:19,250 --> 00:03:22,203
你认为我们将需要评估 fibonacci(31) 多少次呢？

