1
00:00:00,430 --> 00:00:04,400
答案是 13 这个原因很

2
00:00:04,400 --> 00:00:07,140
有趣 如果你看一下我们迄今获得的答案 这是

3
00:00:07,140 --> 00:00:11,790
对于每个数字的调用次数 所以当我们有 fibo(36)

4
00:00:11,790 --> 00:00:16,940
调用数为 1 当输入为 35 则

5
00:00:19,240 --> 00:00:26,010
调用数也是 1 当输入为 34 调用数为 2

6
00:00:26,010 --> 00:00:28,400
当输入为 33 调用数

7
00:00:28,400 --> 00:00:32,189
是 3 当输入为 32

8
00:00:32,189 --> 00:00:35,220
调用数为 5 我们应该开始

9
00:00:35,220 --> 00:00:39,190
注意到一个模式 这也正是我们这里

10
00:00:39,190 --> 00:00:42,420
正在计算的斐波纳契数列 我们每次将 n

11
00:00:42,420 --> 00:00:44,770
减去 1 所以要获得 32 的调用数

12
00:00:44,770 --> 00:00:51,670
我们将它之前 1 个的调用数加上 之前 2 个的

13
00:00:51,670 --> 00:00:53,950
调用数 如果你看一下这个的结构

14
00:00:53,950 --> 00:00:56,950
它遵循了我们考虑兔子

15
00:00:56,950 --> 00:01:00,320
繁殖数量时已有的相同规则

16
00:01:00,320 --> 00:01:03,600
我们在上一个级别拥有的每一只兔子

17
00:01:03,600 --> 00:01:07,140
都多引出了2个 这意味着当我们

18
00:01:07,140 --> 00:01:09,720
做这个加法 我们拥有之前所有的调用

19
00:01:09,720 --> 00:01:12,430
所以我们在上一个级别调用了1 次 34

20
00:01:12,430 --> 00:01:15,180
我们将产生两次新的调用 只是

21
00:01:15,180 --> 00:01:16,850
输入不同 但是 如果我们看一下

22
00:01:16,850 --> 00:01:20,140
输入的分配方式 我们在这里有 2 + 1

23
00:01:20,140 --> 00:01:28,180
对于 34 我们有 1 + 1 对于 33 我们有 2 + 1 对于 32 我们

24
00:01:28,180 --> 00:01:31,020
有 2 + 3 我们有 5 对于 31

25
00:01:31,020 --> 00:01:35,250
我们将有 8 次调用 然后对于 30 我们将有

26
00:01:35,250 --> 00:01:37,050
5 + 8 也就是 13

27
00:01:37,050 --> 00:01:40,240
这将继续下去 这些数字很快就将变的

28
00:01:40,240 --> 00:01:43,135
相当大 我们需要调用的次数

29
00:01:43,135 --> 00:01:47,580
我们每次评估 fibo 36 时

30
00:01:47,580 --> 00:01:50,350
那么评估的调用次数 我们从

31
00:01:50,350 --> 00:01:53,540
36 开始的话 将是

32
00:01:53,540 --> 00:01:57,030
fibo (36 - n -1)  所以在评估

33
00:01:57,030 --> 00:02:00,430
fibo(36) 时 我们需要调用 fibo(2) 的次数

34
00:02:00,430 --> 00:02:04,090
将是 fibo(33) 次 而我们还不知道

35
00:02:04,090 --> 00:02:06,590
该数字是多少 因为当我们试图

36
00:02:06,590 --> 00:02:10,850
使用我们的递归定义评估 fibonacci 36 时 我们的

37
00:02:10,850 --> 00:02:14,210
评估超时 所以我们现在麻烦了 如果我们

38
00:02:14,210 --> 00:02:16,610
想弄清楚有多少次调用

39
00:02:16,610 --> 00:02:19,630
我们需要的一个更有效的方式来计算 fibonacci 数字

40
00:02:20,680 --> 00:02:23,320
所以 让我们看看我们是否能够做到这一点

41
00:02:23,320 --> 00:02:25,540
现在如此低效率的原因是因为我们正在做

42
00:02:25,540 --> 00:02:28,202
很多冗余的工作 对不对？我们看到

43
00:02:28,202 --> 00:02:32,712
为了计算 fibonacci 36 那么我们必须计算 fibonacci 35

44
00:02:32,712 --> 00:02:35,746
并且我们不得不计算 fibonacci 34 以及所有

45
00:02:35,746 --> 00:02:39,560
计算 fibonacci 34 需要做的工作 我们在这里做了

46
00:02:39,560 --> 00:02:42,040
一模一样的事情 对不对？这产生相同的

47
00:02:42,040 --> 00:02:45,790
输出 有大量大量的冗余计算在进行

48
00:02:45,790 --> 00:02:48,200
所以 如果我们要更有效地计算 我们

49
00:02:48,200 --> 00:02:50,700
不想重复所有的工作 我们需要

50
00:02:50,700 --> 00:02:52,760
用一种 不需要重复计算

51
00:02:52,760 --> 00:02:55,780
同样事情的方法 所以 这个问题的

52
00:02:55,780 --> 00:02:59,980
解决方法 不是使用一个递归过程

53
00:02:59,980 --> 00:03:03,390
来计算 fibonacci 我们将使用

54
00:03:03,390 --> 00:03:06,900
一个 while 循环 凡是我们可以用递归定义的

55
00:03:06,900 --> 00:03:09,550
我们也可以不使用递归来定义

56
00:03:10,650 --> 00:03:12,690
使用递归定义 思考起来

57
00:03:12,690 --> 00:03:15,840
往往更容易、更清晰 但通常不是

58
00:03:15,840 --> 00:03:18,450
计算的最快捷的方式 当然 在这样的

59
00:03:18,450 --> 00:03:22,210
情况下 因为所有的冗余计算 这是一个非常、非常

60
00:03:22,210 --> 00:03:26,100
低效的方式来计算 fibonacci 所以让我们尝试

61
00:03:26,100 --> 00:03:29,020
使用 while 循环来解答 然后我们会做一个小练习

