1
00:00:00,330 --> 00:00:03,630
我们已经看到几个例子用来测量运行时间的

2
00:00:03,630 --> 00:00:07,320
玩具程序 一个没什么作用的循环 我们关心的

3
00:00:07,320 --> 00:00:11,440
是我们索引代码的执行时间 所以我

4
00:00:11,440 --> 00:00:14,610
接下来要做的是写一个程序 能够测试

5
00:00:14,610 --> 00:00:17,580
索引的代码执行时间 为了得到一个很好的测试 我们

6
00:00:17,580 --> 00:00:19,650
需要做一个大的索引 我们需要填充

7
00:00:19,650 --> 00:00:22,440
很多很多的词到索引中 我们可以亲手做到这一点

8
00:00:22,440 --> 00:00:25,430
这将花费大量的时间和精力 那么 我要

9
00:00:25,430 --> 00:00:28,054
做的是要找到一个方法去构建一个

10
00:00:28,054 --> 00:00:31,430
大的索引 它要做的是输入 size

11
00:00:31,430 --> 00:00:34,370
然后它会在一个索引中填充这个数量 ( size )

12
00:00:34,370 --> 00:00:37,060
的词语 为了填充这么多数量的

13
00:00:37,060 --> 00:00:39,540
关键词 我们需要产生不同的词 所以呢

14
00:00:39,540 --> 00:00:42,828
我所做的就是创建了 letters 变量 初始化为

15
00:00:42,828 --> 00:00:46,960
全部都是 a 当我们经过循环 我们

16
00:00:46,960 --> 00:00:50,450
经过 size 数量的循环次数 我们继续创建

17
00:00:50,450 --> 00:00:53,613
一个新的字符串 我们将该字符串添加到下一个 我稍后会

18
00:00:53,613 --> 00:00:57,055
解释 make_string 做什么 我们将该字符串添加到

19
00:00:57,055 --> 00:00:59,730
索引 然后我们换个字母 然后我们

20
00:00:59,730 --> 00:01:05,519
要不断增加字母 直到我们到 z 然后绕回来 现在

21
00:01:05,519 --> 00:01:08,530
理解这段代码中的一切并不太重要 但是

22
00:01:08,530 --> 00:01:10,110
我想要进一步讲解一点这段代码

23
00:01:10,110 --> 00:01:12,550
那么 这个循环做的是 遍历所有

24
00:01:12,550 --> 00:01:15,825
现在 letters 中是 a 的位置 然后我们将其填充为

25
00:01:15,825 --> 00:01:19,420
八个不同的元素 我们遍历这些元素 要从

26
00:01:19,420 --> 00:01:23,130
最后一个开始 所以这个循环范围从

27
00:01:23,130 --> 00:01:25,840
列表长度 - 1 到 0 逐步 - 1 我们

28
00:01:25,840 --> 00:01:29,750
要检查每个字母 如果这个字母小于 z

29
00:01:29,750 --> 00:01:31,790
这意味着我们可以增加 我们要增加它

30
00:01:31,790 --> 00:01:35,410
通过使用此代码 我会很快谈到

31
00:01:35,410 --> 00:01:38,160
将字母转换为数字的代码 但是这个表达式所做的

32
00:01:38,160 --> 00:01:41,340
就是获取下一个字母 所以 如果这个字母之前是一个 a

33
00:01:41,340 --> 00:01:44,530
之后的结果就将是一个 b 然后我们将替换

34
00:01:44,530 --> 00:01:48,260
在字母列表中该位置的字母为下一个字母

35
00:01:48,260 --> 00:01:50,670
如果字母是一个 z 我们不想

36
00:01:50,670 --> 00:01:53,350
超越字母表 所以与前面不同 我们要设置字母为 a

37
00:01:53,350 --> 00:01:56,350
我们要通过循环返回以找到

38
00:01:56,350 --> 00:01:58,830
下一个字母 一旦我们发现一个小于 z 我们

39
00:01:58,830 --> 00:02:02,110
break 我们只需要改变一个字母 make_string 过程

40
00:02:02,110 --> 00:02:07,000
所做的 我们在这里调用的 仅仅是将这个数组转化为

41
00:02:07,000 --> 00:02:09,880
一个字符串 因此 它会遍历 p 的元素 p 就是

42
00:02:09,880 --> 00:02:13,360
那不断变化的字母列表 并将所有这些

43
00:02:13,360 --> 00:02:16,320
字母连接为一个字符串 所以 所有这些的关键就是

44
00:02:16,320 --> 00:02:19,390
让我们轻松地做出大的索引 使得我们可以运行

45
00:02:19,390 --> 00:02:23,450
不同大小的索引来测试 因此 让我们在 Python 命令行试试这个

46
00:02:23,450 --> 00:02:25,750
首先 我将展示当我们使用 make_big_index 时的结果

47
00:02:25,750 --> 00:02:28,875
我们将从一个相当小的数字开始 所以我传入

48
00:02:28,875 --> 00:02:32,100
3 的大小 make_big_index 给我们的是一个

49
00:02:32,100 --> 00:02:37,980
有三个关键词的索引 aaaaaaaa、aaaaaaab、aaaaaaac 然后对于

50
00:02:37,980 --> 00:02:40,300
它们中的每一个都有一个叫做 fake 的 url

51
00:02:40,300 --> 00:02:43,720
如果我们传入一个较大的值

52
00:02:43,720 --> 00:02:46,950
这将是一个有100个关键词的索引 所以我们

53
00:02:46,950 --> 00:02:48,940
将传入 100 的大小 我们得到

54
00:02:48,940 --> 00:02:50,910
这个大索引 你可以看到它开始

55
00:02:50,910 --> 00:02:54,430
改变倒数第二个字母了 为了确保

56
00:02:54,430 --> 00:02:56,910
每个词都是与下一个不同的词

57
00:02:56,910 --> 00:02:58,730
所以 我们现在要做的是看看

58
00:02:58,730 --> 00:03:02,760
不同大小的索引的执行时间如何 所以

59
00:03:02,760 --> 00:03:06,520
让我们做一个非常大的索引 所以 我们要做的是

60
00:03:06,520 --> 00:03:10,540
我们会创建一个10000大小的索引 记住 我们关注的

61
00:03:10,540 --> 00:03:13,080
是查找的时间 这是最频繁发生的操作

62
00:03:13,080 --> 00:03:16,090
因此 我们不是测量创建大索引

63
00:03:16,090 --> 00:03:18,590
所需的时间 让我们看看做一次查找的

64
00:03:18,590 --> 00:03:21,970
时间是多少 所以我将测量查询

65
00:03:21,970 --> 00:03:26,530
10000个关键词的索引所需的时间 这个词会有所

66
00:03:26,530 --> 00:03:28,860
差异 因此 首先让我们试着查找

67
00:03:28,860 --> 00:03:32,550
这个词 udacity 很遗憾 它没有在

68
00:03:32,550 --> 00:03:35,260
我们的索引中 我们需要一个更大的索引

69
00:03:35,260 --> 00:03:42,218
才能达到 udacity 然后执行的时间在此显示 因此 它是0.0008秒

70
00:03:42,218 --> 00:03:44,880
所以 仍然接近一毫秒

71
00:03:44,880 --> 00:03:47,950
但还是相当快的 让我们做一个更大的索引

72
00:03:47,950 --> 00:03:50,770
这一次 我们有10万的关键词 要花费

73
00:03:50,770 --> 00:03:52,660
更长的时间来创建它 但我们不用

74
00:03:52,660 --> 00:03:54,932
担心现在创建它的时间

75
00:03:54,932 --> 00:03:56,560
我们关心的是做一次查找的时间

76
00:03:58,910 --> 00:04:03,020
这样花了很长时间 让我们看看如何 有很多条目 所以我们可以看看

77
00:04:03,020 --> 00:04:08,990
我们索引中的最后一个元素 然后我们可以看到是 aaaafryd

78
00:04:08,990 --> 00:04:14,170
我不知道它的发音 另一种看到它的方式

79
00:04:14,170 --> 00:04:16,140
我们还没有谈到 我们实际上可以使用

80
00:04:16,140 --> 00:04:18,579
-1 来做 index 操作 因此 如果你使用 -1 作为

81
00:04:18,579 --> 00:04:21,190
索引 将给到我们列表的最后一个条目

82
00:04:21,190 --> 00:04:24,360
所以 现在我们将尝试做一次计时的执行 我们要

83
00:04:24,360 --> 00:04:26,920
在10000大小的索引中查找 我们会

84
00:04:26,920 --> 00:04:29,680
看到时间与之前的非常相似

85
00:04:29,680 --> 00:04:31,300
时间会稍微有一点不同 让我们再次

86
00:04:31,300 --> 00:04:34,390
试一下 然后再一次的 它仅仅是不到一毫秒

87
00:04:34,390 --> 00:04:38,212
所以 现在 我们将不是尝试10000大小的索引

88
00:04:38,212 --> 00:04:42,736
而是在10万大小的索引中查找 同样的查询

89
00:04:42,736 --> 00:04:44,920
我们看到 现在时间是10倍

90
00:04:44,920 --> 00:04:49,366
所以它现在大约是8.6毫秒 而它在之前

91
00:04:49,366 --> 00:04:55,330
是0.9毫秒 然后让我们 为了保持一致性 再试一次

92
00:04:55,330 --> 00:04:57,480
我们会注意到 这些时间每次都会变化一点点

93
00:04:57,480 --> 00:05:00,020
这里有很多的原因导致时间会

94
00:05:00,020 --> 00:05:03,490
变化 我们在计算机上同时运行很多其他的东西

95
00:05:03,490 --> 00:05:06,970
所以 这不是我们对处理器有完全

96
00:05:06,970 --> 00:05:09,590
控制的情况 并且每次都运行完全相同的事情

97
00:05:09,590 --> 00:05:11,800
因为所有其他程序可能正在做其他事情

98
00:05:11,800 --> 00:05:14,370
时间可能不同的另一个原因是 事物在

99
00:05:14,370 --> 00:05:17,600
内存的位置 有时在内存中查找一个值很快

100
00:05:17,600 --> 00:05:20,690
有时需要更长的时间 而且我们不打算

101
00:05:20,690 --> 00:05:23,530
谈论这方面的细节 重要的是

102
00:05:23,530 --> 00:05:26,820
每次我们执行它的时间是大致相同的

103
00:05:26,820 --> 00:05:30,760
它真的取决于输入的大小 在这种

104
00:05:30,760 --> 00:05:33,240
情况下 它是输入表的大小 所以 当我们

105
00:05:33,240 --> 00:05:36,106
增加表的大小 以具有100000个条目

106
00:05:36,106 --> 00:05:39,840
它大约是我们有10,000个条目时的10倍慢

107
00:05:39,840 --> 00:05:43,450
所以现在 让我们做几个小练习 看看你是否能猜到这些时间是如何工作的

