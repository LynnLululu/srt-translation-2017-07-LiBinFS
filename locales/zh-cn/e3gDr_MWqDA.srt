1
00:00:00,450 --> 00:00:04,570
这里介绍一种定义 make_hashtable 函数的方法

2
00:00:04,570 --> 00:00:09,710
我们先来初始化一个变量 i=0 我们需要一直记录桶的数量 那么我们先建一个空表

3
00:00:09,710 --> 00:00:11,940
然后我们想做的是在其中添加 n 个存储桶

4
00:00:11,940 --> 00:00:14,520
也就是表中的桶的数量

5
00:00:14,520 --> 00:00:17,500
那么我们来用 while 循环 当变量 i 小于桶的数量时保持循环

6
00:00:17,500 --> 00:00:20,110
所以每次经过一次循环

7
00:00:20,110 --> 00:00:22,000
我们希望在哈希表中添加

8
00:00:22,000 --> 00:00:25,770
一个空的桶 我们可以用 Append

9
00:00:25,770 --> 00:00:28,130
它增加一个新的空桶 我们需要

10
00:00:28,130 --> 00:00:31,850
记得增加变量 i 来保证

11
00:00:31,850 --> 00:00:34,160
不会永远循环下去 我们通过

12
00:00:34,160 --> 00:00:38,710
循环 n 个桶的次数 每次增加一个空桶

13
00:00:38,710 --> 00:00:41,030
到表中 然后我们在最后返回这个表

14
00:00:41,030 --> 00:00:44,660
那么让我们用 Python 来试一下

15
00:00:44,660 --> 00:00:48,040
这个代码就像我们刚说的

16
00:00:48,040 --> 00:00:50,920
然后我们打印出 make_hashtable 函数的结果

17
00:00:50,920 --> 00:00:53,670
为了打印我们让桶的数量小一些

18
00:00:53,670 --> 00:00:56,710
在真实的使用中会远远超过3个桶

19
00:00:56,710 --> 00:01:00,330
然后我们来运行 我们看到我们得到的列表

20
00:01:00,330 --> 00:01:04,519
是有三个空表作为元素 所以这个是可以运行的 它看起来比我们需要

21
00:01:04,519 --> 00:01:06,980
的代码多很多 的确是比我们需要的代码多

22
00:01:06,980 --> 00:01:09,210
有个更好的方式来写 就是用一个

23
00:01:09,210 --> 00:01:11,900
for 循环 那么我们通常见到的 for 循环的结构呢

24
00:01:11,900 --> 00:01:16,000
我们见过的 for 循环的结构是像这样

25
00:01:16,000 --> 00:01:18,540
这里的 collection 可以是一个列表

26
00:01:18,540 --> 00:01:22,520
可以是一个字符串 要想有一个 for 循环 我们需要

27
00:01:22,520 --> 00:01:25,180
一些循环的对象 在这个例子里

28
00:01:25,180 --> 00:01:28,150
我们想要的是从 0 循环到 n-1 个桶

29
00:01:28,150 --> 00:01:31,510
那么我们想建立一个列表

30
00:01:31,510 --> 00:01:34,590
包含了这些值 所以我们想

31
00:01:34,590 --> 00:01:36,840
按这个顺序能够定义 make_hashtable 函数

32
00:01:36,840 --> 00:01:41,330
是能够有一个从 0 到 n-1 个桶的列表

33
00:01:41,330 --> 00:01:44,530
Python 提供了简单的方式

34
00:01:44,530 --> 00:01:47,110
名字叫 range 函数

35
00:01:47,110 --> 00:01:50,150
range 的输入是两个数 定义为 start 和 stop

36
00:01:50,150 --> 00:01:53,100
其输出的是一个

37
00:01:53,100 --> 00:01:56,830
从 start 到 stop-1 的列表

38
00:01:56,830 --> 00:01:59,470
那么这个就是 range 的输出 一个数的列表 从 start 开始

39
00:01:59,470 --> 00:02:02,957
按1递增 直到 stop-1

40
00:02:02,957 --> 00:02:06,340
我们会看到它并不包括

41
00:02:06,340 --> 00:02:08,919
从列表第二个参数传递进来的值

42
00:02:08,919 --> 00:02:11,470
这个函数很有用 因为经常当我们看元素的时候

43
00:02:11,470 --> 00:02:14,390
我们不希望包括最后那个元素

44
00:02:14,390 --> 00:02:18,310
这意味着如果我们求从 0 到 10 的 range

45
00:02:20,400 --> 00:02:26,250
得到的结果是0,1,2 到 9 的列表

46
00:02:26,250 --> 00:02:29,210
那么现在我们了解 range 了 我们可以修改我们的循环了

47
00:02:29,210 --> 00:02:32,160
我们用 for 循环来替代 while 循环

48
00:02:32,160 --> 00:02:34,360
这么做有两个原因

49
00:02:34,360 --> 00:02:36,590
首先可以让我们代码短一些

50
00:02:36,590 --> 00:02:39,130
通常能让代码短一些的事情就是好事情

51
00:02:39,130 --> 00:02:42,430
第二可以避免我们忘记增加变量而产生的风险

52
00:02:42,430 --> 00:02:45,440
这是个常发生的错误 当我们忘记

53
00:02:45,440 --> 00:02:47,740
增加变量 循环就永远在跑了

54
00:02:47,740 --> 00:02:50,050
所以如果可以用 for 循环替换 while 循环 也通常

55
00:02:50,050 --> 00:02:53,530
是个好主意 那么更好地定义 make_hashtable 的方式

56
00:02:53,530 --> 00:02:56,770
是用 for 循环 我们不再需要变量 i

57
00:02:56,770 --> 00:03:00,490
我们仍然需要表 我们不用 while 循环

58
00:03:00,490 --> 00:03:03,400
而用 for 来做循环 我们暂时让

59
00:03:03,400 --> 00:03:05,780
变量名空着 一会儿再看看在那放什么

60
00:03:05,780 --> 00:03:10,570
用什么来做循环 那么我们循环的是

61
00:03:10,570 --> 00:03:12,720
对0到n个存储桶进行 range 我们想看看

62
00:03:12,720 --> 00:03:17,350
n 个桶中的元素 这应该是

63
00:03:17,350 --> 00:03:20,800
一个 0 到 n-1 个桶的列表

64
00:03:20,800 --> 00:03:25,050
然后对于其中的每一个 我们在表中添加一个新桶

65
00:03:25,050 --> 00:03:27,540
就像我们之前所做的 我们不需要

66
00:03:27,540 --> 00:03:29,880
增加变量 i 这里不再有变量 i

67
00:03:29,880 --> 00:03:33,440
在循环结束的时候 像之前一样返回表

68
00:03:33,440 --> 00:03:35,950
对于这个循环 我们不需要一个真的变量 对吧

69
00:03:35,950 --> 00:03:38,550
我们从没在循环里用变量 对于这个

70
00:03:38,550 --> 00:03:41,320
for 循环的索引 我们在这儿还需要点东西 所以我就

71
00:03:41,320 --> 00:03:46,280
称之为 unused 为了清楚的表示在这里有个名字

72
00:03:46,280 --> 00:03:48,670
虽然实际上在方案的主体中并没有用到它

73
00:03:48,670 --> 00:03:51,100
这可以让代码短很多

74
00:03:51,100 --> 00:03:53,730
这个的效果和我们之前做的一样

75
00:03:53,730 --> 00:03:57,290
这个是新的代码 很多行比我们之前那个短很多

76
00:03:57,290 --> 00:04:01,240
但效果一模一样 如果你更聪明的话

77
00:04:01,240 --> 00:04:03,630
可能会想到让代码更精炼的办法

78
00:04:03,630 --> 00:04:06,620
来定义 make_hashtable 很不幸并不好用

79
00:04:06,620 --> 00:04:10,140
因此更精炼的办法是猜

80
00:04:10,140 --> 00:04:13,300
运算处理列表的时间

81
00:04:13,300 --> 00:04:15,680
和处理字符串的时间一样 所以我们可以

82
00:04:15,680 --> 00:04:21,339
创建一个空列表 乘上 n 个桶

83
00:04:21,339 --> 00:04:23,710
这看起来赞 它只有一行语句 清晰易懂

84
00:04:23,710 --> 00:04:26,690
而且看起来几乎是能成功的

85
00:04:26,690 --> 00:04:30,250
那我们用 Python 编译器试试

86
00:04:30,250 --> 00:04:33,170
看起来是成功 得到了一个哈希表 里面有三个空桶的列表

87
00:04:33,170 --> 00:04:37,790
但这个方法有个很大问题 我给你们点提示

88
00:04:37,790 --> 00:04:40,340
然后我们会有个测试

89
00:04:40,340 --> 00:04:42,550
来看看你们有没有想到为什么 那么我们不直接打印 

90
00:04:42,550 --> 00:04:46,460
出结果 我们将它赋值给变量 table

91
00:04:46,460 --> 00:04:49,220
然后我们模拟往哈希表中加东西 看看会发生什么

92
00:04:49,220 --> 00:04:52,760
也就是我们来向桶里面加点东西

93
00:04:52,760 --> 00:04:56,300
我们选一号桶 假设

94
00:04:56,300 --> 00:05:01,470
我们为 udacity 添加一个

95
00:05:01,470 --> 00:05:03,870
url 链接 现在我们来打印

96
00:05:03,870 --> 00:05:06,950
看一下桶里的内容 看起来还不错

97
00:05:06,950 --> 00:05:09,870
那零号桶里有什么呢

98
00:05:09,870 --> 00:05:13,420
结果也是一样的 那我们来想想

99
00:05:13,420 --> 00:05:17,790
哪儿出了问题 我会出个题来看看你们是否知道

100
00:05:17,790 --> 00:05:21,610
为什么这种简单定义 make_hashtable 的办法没有正确运行

