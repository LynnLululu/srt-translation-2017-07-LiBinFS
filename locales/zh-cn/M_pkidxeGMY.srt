1
00:00:00,000 --> 00:00:05,500
对于这道题目 我将解释下如何传入输入字符串

2
00:00:05,500 --> 00:00:10,310
这里是 ···X····

3
00:00:10,310 --> 00:00:13,320
并根据某种规则更改该字符串

4
00:00:13,320 --> 00:00:14,990
规则如下：

5
00:00:14,990 --> 00:00:18,370
查看字符串中的三个字符

6
00:00:18,370 --> 00:00:20,370
并根据这里的规则

7
00:00:20,370 --> 00:00:22,950
更改中间的字符

8
00:00:22,950 --> 00:00:25,970
暂时不要管这些数字 稍后我会讲解

9
00:00:25,970 --> 00:00:29,140
对于这三个字符

10
00:00:29,140 --> 00:00:31,140
分别是··X

11
00:00:31,140 --> 00:00:34,450
··X 表示将中间的元素

12
00:00:34,450 --> 00:00:36,450
更改为 X

13
00:00:36,450 --> 00:00:38,840
对于下个字符串 即新的字符串

14
00:00:38,840 --> 00:00:40,840
这个位置将是 X

15
00:00:40,840 --> 00:00:42,840
该位置之前的位置

16
00:00:42,840 --> 00:00:44,840
···

17
00:00:44,840 --> 00:00:47,610
···变成

18
00:00:47,610 --> 00:00:49,120
中间的一个 ·

19
00:00:49,120 --> 00:00:50,760
对于两边的字符

20
00:00:50,760 --> 00:00:53,210
我们需要连接起来

21
00:00:53,210 --> 00:00:55,960
对于这里的这个 ·

22
00:00:55,960 --> 00:00:57,600
左侧是个 ·

23
00:00:57,600 --> 00:00:59,110
右侧是个 ·

24
00:00:59,110 --> 00:01:01,110
还是 ···

25
00:01:01,110 --> 00:01:03,600
··· 表示将中间字符改成

26
00:01:03,600 --> 00:01:05,330
一个 ·

27
00:01:05,330 --> 00:01:07,030
继续

28
00:01:07,030 --> 00:01:11,100
接着要填充的是 ·X·

29
00:01:11,100 --> 00:01:14,170
·X· 表示将中间元素改成 X

30
00:01:14,170 --> 00:01:18,270
X··

31
00:01:18,270 --> 00:01:20,270
将中间元素变成 X

32
00:01:20,270 --> 00:01:21,940
还是 ···

33
00:01:21,940 --> 00:01:23,740
中间是 ·

34
00:01:23,740 --> 00:01:26,390
··· 中间是 ·

35
00:01:26,390 --> 00:01:28,650
··

36
00:01:28,650 --> 00:01:31,270
最后一个是这个第一个点

37
00:01:31,270 --> 00:01:34,180
··· 还是 ·

38
00:01:34,180 --> 00:01:37,790
字符串第一次更改完毕

39
00:01:37,790 --> 00:01:39,790
我们需要再重复一遍

40
00:01:39,790 --> 00:01:42,600
这是第一次 generation

41
00:01:42,600 --> 00:01:44,600
这是第二次 generation

42
00:01:44,600 --> 00:01:48,230
通常 我们会从字符串的开头开始操作

43
00:01:48,230 --> 00:01:51,310
但是这里只是为了展示在中间更好操作

44
00:01:51,310 --> 00:01:54,360
这次我们将从字符串的开头开始

45
00:01:54,360 --> 00:01:57,010
看看上面这行内容

46
00:01:57,010 --> 00:02:00,520
第一个元素的

47
00:02:00,520 --> 00:02:03,270
左侧是个 ·

48
00:02:03,270 --> 00:02:05,950
右侧是个 · 所以是 ···

49
00:02:05,950 --> 00:02:07,650
结果是 ·

50
00:02:07,650 --> 00:02:09,650
现在是 ··X

51
00:02:09,650 --> 00:02:12,890
··X 是这里的数字 2

52
00:02:12,890 --> 00:02:14,890
得出 X

53
00:02:14,890 --> 00:02:17,350
·XX 是 X

54
00:02:17,350 --> 00:02:20,070
XXX 是 ·

55
00:02:20,070 --> 00:02:24,030
XX· 是 ·

56
00:02:24,030 --> 00:02:28,200
X·· 是 X

57
00:02:28,200 --> 00:02:31,200
··· 是 ·

58
00:02:31,200 --> 00:02:34,770
··· 还是 ·

59
00:02:34,770 --> 00:02:37,050
继续下去

60
00:02:37,050 --> 00:02:41,020
转变五次之后

61
00:02:41,020 --> 00:02:45,210
得出字符串 ···XX·XX

62
00:02:45,210 --> 00:02:47,890
可以看出出现了有趣的规律

63
00:02:47,890 --> 00:02:51,920
我们可以根据第二行

64
00:02:51,920 --> 00:02:54,300
用蓝色表示的 · 和 X 选项

65
00:02:54,300 --> 00:02:56,300
执行很多次操作

66
00:02:56,300 --> 00:02:59,830
实际上 可以有 256 个不同的方式

67
00:02:59,830 --> 00:03:03,540
为了判断我们将使用哪个 pattern

68
00:03:03,540 --> 00:03:06,140
即哪个规则

69
00:03:06,140 --> 00:03:08,550
我们可以为这些规则编个号

70
00:03:08,550 --> 00:03:11,880
只要底部有个 X

71
00:03:11,880 --> 00:03:13,620
我就将这些数字相加

72
00:03:13,620 --> 00:03:18,190
即 2 + 4 + 8 + 16

73
00:03:18,190 --> 00:03:20,190
结果是 30

74
00:03:20,190 --> 00:03:24,710
所以这里使用的是 pattern 30

75
00:03:24,710 --> 00:03:28,360
我们可以选择不同的 pattern 而不是 pattern 30

76
00:03:28,360 --> 00:03:31,740
假设选择 pattern 69

77
00:03:31,740 --> 00:03:35,040
69 等于。。。

78
00:03:35,040 --> 00:03:37,690
我们需要查看上面的这些数字

79
00:03:37,690 --> 00:03:40,380
想想哪些数字相加

80
00:03:40,380 --> 00:03:42,260
等于 69

81
00:03:42,260 --> 00:03:46,280
加上 128 肯定不等于 69 所以不需要这些

82
00:03:46,280 --> 00:03:49,370
64 可以 所以写上 64

83
00:03:49,370 --> 00:03:51,510
不需要 32

84
00:03:51,510 --> 00:03:54,200
不需要 16 也不需要 8

85
00:03:54,200 --> 00:03:56,020
但是需要 4

86
00:03:56,020 --> 00:03:58,540
不需要 2 但是需要 1

87
00:03:58,540 --> 00:04:02,650
所以 64 + 4 + 1 等于 69

88
00:04:02,650 --> 00:04:05,140
意味着我们需要 1

89
00:04:05,140 --> 00:04:07,910
我们将 ··· 的

90
00:04:07,910 --> 00:04:09,910
中间元素替换为 X

91
00:04:09,910 --> 00:04:12,710
不需要 2 的确需要 4

92
00:04:12,710 --> 00:04:14,710
不需要 8

93
00:04:14,710 --> 00:04:16,709
不需要 16

94
00:04:16,709 --> 00:04:18,709
不需要 32

95
00:04:18,709 --> 00:04:20,709
需要 64

96
00:04:20,709 --> 00:04:23,390
不需要 128

97
00:04:23,390 --> 00:04:27,870
可以和之前的输入一样开始

98
00:04:27,870 --> 00:04:32,410
即···X····

99
00:04:32,410 --> 00:04:36,110
当开头是个 ·

100
00:04:36,110 --> 00:04:38,230
左侧是个 ·

101
00:04:38,230 --> 00:04:39,810
右侧是个 ·

102
00:04:39,810 --> 00:04:43,730
··· 替换成 X

103
00:04:43,730 --> 00:04:46,440
还是 ··· 变成 X

104
00:04:46,440 --> 00:04:48,610
··X 变成 ·

105
00:04:48,610 --> 00:04:50,510
注意 我们看的是下面的元素

106
00:04:50,510 --> 00:04:54,760
·X· 对应数字 4 是个 X

107
00:04:54,760 --> 00:04:58,220
X·· 是个 ·

108
00:04:58,220 --> 00:05:02,140
··· 是个 X

109
00:05:02,140 --> 00:05:06,350
··· 还是 X

110
00:05:06,350 --> 00:05:08,350
这就是第一行的内容

111
00:05:08,350 --> 00:05:13,350
继续下去 再填充几行内容

112
00:05:13,350 --> 00:05:15,350
看看 pattern 会出现什么情况

113
00:05:15,350 --> 00:05:17,700
现在到了第 6 行

114
00:05:17,700 --> 00:05:22,800
发现这行和第 5 行的完全一样

115
00:05:22,800 --> 00:05:26,640
意味着第 7 行也会完全一样

116
00:05:26,640 --> 00:05:30,850
某些值使这些 pattern 变得稳定起来

117
00:05:30,850 --> 00:05:34,660
其他值的结果则比较混乱

118
00:05:34,660 --> 00:05:36,660
所以有很多规律值得研究

119
00:05:36,660 --> 00:05:40,270
现在看看实际的代码

120
00:05:40,270 --> 00:05:46,820
现在请你传入一个字符串

121
00:05:46,820 --> 00:05:51,350
即由 · 和 X 构成的字符串

122
00:05:51,350 --> 00:05:57,900
pattern 数字 即 0 到 255 之间的数字

123
00:05:57,900 --> 00:06:05,520
并据此判断哪些位置是 · 哪些是 X

124
00:06:05,520 --> 00:06:09,280
我会提供这里的这些信息

125
00:06:09,280 --> 00:06:13,680
也就是与 XX· 对应的数字

126
00:06:13,680 --> 00:06:15,680
你将研究这一 pattern

127
00:06:15,680 --> 00:06:21,140
最后是重复次数 是个正整数

128
00:06:21,140 --> 00:06:23,550
1 2 3 4 等等

129
00:06:23,550 --> 00:06:27,330
输出应该是 generation

130
00:06:27,330 --> 00:06:31,010
或在 generation n 处的字符串

131
00:06:31,010 --> 00:06:37,340
例如 如果输入字符串是这些

132
00:06:37,340 --> 00:06:40,510
pattern 是 69

133
00:06:40,510 --> 00:06:42,840
generation 是 5

134
00:06:42,840 --> 00:06:51,622
则应该返回“.x.x.x.x”
