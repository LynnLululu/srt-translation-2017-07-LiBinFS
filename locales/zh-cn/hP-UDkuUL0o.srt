1
00:00:00,000 --> 00:00:04,000
对于这个问题 你需要修改排名计算代码

2
00:00:04,000 --> 00:00:10,000
以便考虑链接是否是交互链接

3
00:00:10,000 --> 00:00:16,000
我们想知道的是 a -> c 是否是交互链接

4
00:00:16,000 --> 00:00:25,000
如果有从 c 回到 a 的路径 长度最长为 k

5
00:00:25,000 --> 00:00:28,000
k 是给定的数字

6
00:00:28,000 --> 00:00:35,000
如果有反向路径 那么在计算 c 的排名时就不会考虑 a

7
00:00:35,000 --> 00:00:39,000
我将看看 k 的值 k = 0

8
00:00:39,000 --> 00:00:43,000
我要思考 a -> c 是交互链接吗？

9
00:00:43,000 --> 00:00:51,000
然后就可以判断在计算 c 的排名时是否包含 a

10
00:00:51,000 --> 00:00:55,000
如果 k = 0 这是我们要研究的链接

11
00:00:55,000 --> 00:01:03,000
如果 k = 0 唯一排除的链接是自链接 即指向页面本身的链接

12
00:01:03,000 --> 00:01:09,000
所以这里 a -> c 不是交互链接 我们在计算 c 的排名时应该考虑 a

13
00:01:09,000 --> 00:01:18,000
如果 k = 1 我们要看的是从 c 到 a 是否有直接链接 没有

14
00:01:18,000 --> 00:01:22,000
所以 a -> c 不是交互链接 我们应该包含 a

15
00:01:22,000 --> 00:01:28,000
如果 k = 2 我们需要查看从 c 到 a 是否有长度为 2 的路径

16
00:01:28,000 --> 00:01:32,000
如果从 c 开始 那么只能到达 d

17
00:01:32,000 --> 00:01:38,000
这是我们回到 a 可以点击的链接之一

18
00:01:38,000 --> 00:01:43,000
现在我们要弄明白的是是否可以从 d 点击一个链接回到 a？
19
00:01:43,000 --> 00:01:49,000
答案是否定的 我们不可以 意味着 a -> c 不是交互链接 我们应该包含 a

20
00:01:49,000 --> 00:01:53,000
如果 k = 3 流程还是一样的 从 c 开始

21
00:01:53,000 --> 00:01:55,000
使用一个链接到达 d

22
00:01:55,000 --> 00:02:01,000
然后我们想知道通过点击两次 是否能从 d 回到 a

23
00:02:01,000 --> 00:02:06,000
我们来看看 从 d 可以到达 b

24
00:02:06,000 --> 00:02:11,000
用到了一个链接 再使用一个链接能到达 a 吗？

25
00:02:11,000 --> 00:02:16,000
可以 因为从 b 到 a 有一个直接链接

26
00:02:16,000 --> 00:02:20,000
意味着 a -> c 是交互链接 我们不应该包含 a

27
00:02:20,000 --> 00:02:27,000
如果 k >= 3 那么肯定有一个长度至少为 3 的路径

28
00:02:27,000 --> 00:02:33,000
因此对于 k >= 3 的任何值 我们都不应该包含 a

29
00:02:33,000 --> 00:02:35,000
现在开始编写代码

30
00:02:35,000 --> 00:02:39,000
我们将编写一个过程 检查 a -> c 是否为交互链接

31
00:02:39,000 --> 00:02:46,000
然后编辑代码并在计算排名时考虑这一点

32
00:02:46,000 --> 00:02:48,000
这是提供的代码

33
00:02:48,000 --> 00:02:52,000
我将加以修改 包含第二个输入 k

34
00:02:52,000 --> 00:02:58,000
然后看看是否具有交互链接 包含该网页

35
00:02:58,000 --> 00:03:02,000
如果图表中没有交互链接

36
00:03:02,000 --> 00:03:11,000
如果网页的链接节点不是交互链接 则在计算时包含该节点

37
00:03:11,000 --> 00:03:18,000
这里加几个空格 只需做出这些更改就可以计算排名

38
00:03:18,000 --> 00:03:23,000
要编写 is_reciprocal_link 我将用到递归

39
00:03:23,000 --> 00:03:29,000
如果 k 为 0 这是我们在示例中查看的第一种情况

40
00:03:29,000 --> 00:03:35,000
那么只要目标和来源是一样的 就有交互链接

41
00:03:35,000 --> 00:03:42,000
在这种情况下 返回 True 否则返回 False

42
00:03:42,000 --> 00:03:49,000
如果 k 不等于 0 那么至少为 1 则意味着如果从目标到来源

43
00:03:49,000 --> 00:03:56,000
有一个直接链接 那么很有可能有交互链接

44
00:03:56,000 --> 00:04:04,000
如果不是这种情况 我们将查看目标链接到的每个节点

45
00:04:04,000 --> 00:04:13,000
我们将检查从该节点到来源是否有长度为 k - 1 的链接路径

46
00:04:13,000 --> 00:04:16,000
我们从目标到该节点已经使用了一个步长

47
00:04:16,000 --> 00:04:19,000
现在就剩下 k - 1 个步长

48
00:04:19,000 --> 00:04:27,000
如果有路径 也就是说 如果同一图表中有交互链接

49
00:04:27,000 --> 00:04:29,000
来源一样

50
00:04:29,000 --> 00:04:34,000
新的节点 希望离目标近一个步长

51
00:04:34,000 --> 00:04:38,000
如果是这种情况 则返回 True

52
00:04:38,000 --> 00:04:43,000
如果没有这种节点 则返回 False.

53
00:04:43,000 --> 00:04:46,000
该过程就写完了