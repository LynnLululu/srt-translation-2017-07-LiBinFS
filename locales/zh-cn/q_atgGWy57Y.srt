1
00:00:00,000 --> 00:00:07,000
在这问题中 一开始有 n 个人 有大头和快乐的笑容

2
00:00:07,000 --> 00:00:13,000
之后每个学期 每一个快乐的 udacian 走出去并要求

3
00:00:13,000 --> 00:00:17,000
向他们的朋友宣传选修这个课程

4
00:00:17,000 --> 00:00:23,000
只要 udacians 的数目小于目标值 就继续这个过程

5
00:00:23,000 --> 00:00:27,000
运用一点数学 你可以相当简单地解决这个问题

6
00:00:27,000 --> 00:00:29,000
你可能在初中或高中做过这种问题

7
00:00:29,000 --> 00:00:33,000
不过 我们使用递归 很容易地就能解决这个问题

8
00:00:33,000 --> 00:00:39,000
记住我们寻找的答案是 这个过程要经历多少个学期

9
00:00:39,000 --> 00:00:41,000
才能达到目标值

10
00:00:41,000 --> 00:00:44,000
我看到在论坛中 一些人试图使用全局变量 (global variable)

11
00:00:44,000 --> 00:00:46,000
来数递归调用的次数

12
00:00:46,000 --> 00:00:51,000
但实际上 这么做会破坏我们使用递归力量的目的

13
00:00:51,000 --> 00:00:54,000
我现在要向你展示 如何运用递归

14
00:00:54,000 --> 00:01:01,000
基本情况说 如果已经符合了目标值 我们不再需要为了达到目标

15
00:01:01,000 --> 00:01:05,000
再花任何时间做传播 因为我们已经达成目标了

16
00:01:05,000 --> 00:01:11,000
现在这里 有个 +1  因为我们要说 我们进行了 udacian 传播过程

17
00:01:11,000 --> 00:01:14,000
的一次运算

18
00:01:14,000 --> 00:01:16,000
现在处理递归调用

19
00:01:16,000 --> 00:01:18,000
首先我们需要的是 n

20
00:01:18,000 --> 00:01:23,000
嗯 n 是同样的事情 是上次的值加上得到的新人数

21
00:01:23,000 --> 00:01:25,000
也就是 spread 乘以 n

22
00:01:25,000 --> 00:01:30,000
更简洁的写法是 n x (1 + spread)

23
00:01:30,000 --> 00:01:34,000
传播率 (spreading rate) 不会改变 所以我们不改动它

24
00:01:34,000 --> 00:01:35,000
我们的目标值不会改变

25
00:01:35,000 --> 00:01:38,000
就这样了 我们完成了

