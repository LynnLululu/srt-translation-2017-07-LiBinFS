1
00:00:00,000 --> 00:00:03,000
Manuel 有个问题

2
00:00:03,000 --> 00:00:09,000
“我总觉得递归调用比迭代函数更高效

3
00:00:09,000 --> 00:00:15,000
Evans 教授说在 Python 中 递归定义不是太高效

4
00:00:15,000 --> 00:00:20,000
所以我想问问 其他编程语言 例如 C 或 Java

5
00:00:20,000 --> 00:00:26,000
是否能改善递归调用 以便始终比迭代方法更高效”

6
00:00:26,000 --> 00:00:29,000
Manuel 谢谢你的问题

7
00:00:29,000 --> 00:00:34,000
递归在性能方面存在的问题是

8
00:00:34,000 --> 00:00:39,000
当你执行递归调用时 需要跟踪该调用的状态

9
00:00:39,000 --> 00:00:43,000
这就叫做堆栈帧 你要跟踪你所调用的函数

10
00:00:43,000 --> 00:00:45,000
要跟踪完成之后返回何处

11
00:00:45,000 --> 00:00:50,000
你要留出空间来存储传递到该过程的参数

12
00:00:50,000 --> 00:00:53,000
如果你有个递归调用 每次进行递归调用时

13
00:00:53,000 --> 00:00:56,000
你都需要一个新的堆栈帧来跟踪该调用

14
00:00:56,000 --> 00:00:59,000
当你最终满足基础条件 并得出结果时

15
00:00:59,000 --> 00:01:01,000
则需要展开所有这些调用

16
00:01:01,000 --> 00:01:04,000
重新经过所有这些堆栈帧 返回结果

17
00:01:04,000 --> 00:01:07,000
获取该空间 这一过程需要很多空间

18
00:01:07,000 --> 00:01:11,000
如果有很多递归调用 就像在 101 中看到的示例

19
00:01:11,000 --> 00:01:15,000
如果输入很大的话 就会空间不足

20
00:01:15,000 --> 00:01:20,000
对于某些语言来说 解析器或编译器会进行某种优化

21
00:01:20,000 --> 00:01:24,000
如果递归调用的结果只是用于传递给下一等级

22
00:01:24,000 --> 00:01:29,000
那么你根本不需要跟踪所有这些堆栈

23
00:01:29,000 --> 00:01:32,000
你可以重复利用已有的一个堆栈 只需替换参数

24
00:01:32,000 --> 00:01:35,000
并知道操作完毕后 就是实际的结果

25
00:01:35,000 --> 00:01:38,000
或者需要更复杂的优化 要对结果进行处理

26
00:01:38,000 --> 00:01:42,000
但是不需要跟踪所有这些堆栈帧

27
00:01:42,000 --> 00:01:48,000
大多数语言在使用递归时通常都是这么做的

28
00:01:48,000 --> 00:01:51,000
Lisp 和 Scheme 等语言就是这么设计的

29
00:01:51,000 --> 00:01:53,000
这样 进行递归调用时效率就非常的高

30
00:01:53,000 --> 00:01:57,000
但是依然比迭代的代价要高 因为你依然需要进行调用

31
00:01:57,000 --> 00:02:02,000
你需要调用过程并获得结果

32
00:02:02,000 --> 00:02:04,000
但是借助尾部递归优化

33
00:02:04,000 --> 00:02:07,000
你就不需要跟踪所有这些堆栈帧

34
00:02:07,000 --> 00:02:09,000
比 Python 中的递归调用要高效多了

35
00:02:09,000 --> 00:02:13,000
很多人都问 既然 Python 中的递归过程效率很低

36
00:02:13,000 --> 00:02:15,000
为何还要介绍递归过程呢

37
00:02:15,000 --> 00:02:18,000
原因是递归过程非常有助于我们思考问题

38
00:02:18,000 --> 00:02:23,000
虽然最终需要将这一过程转变为迭代形式

39
00:02:23,000 --> 00:02:27,000
通过编写递归版本 理解递归定义的工作原理

40
00:02:27,000 --> 00:02:31,000
我们其实是以一种全新的强大方式思考问题

41
00:02:31,000 --> 00:02:36,000
递归过程通常比迭代更好推理

42
00:02:36,000 --> 00:02:39,000
如果某个语言提供尾部递归优化

43
00:02:39,000 --> 00:02:43,000
那么通常你需要使用递归定义

44
00:02:43,000 --> 00:02:45,000
在 Python 中 则通常不是这种情况

45
00:02:45,000 --> 00:02:47,000
最好写一个没有递归调用的过程

46
00:02:47,000 --> 00:02:50,000
因为如果对大的输入调用的话 就会耗尽堆栈空间