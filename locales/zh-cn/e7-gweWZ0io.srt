1
00:00:00,200 --> 00:00:01,890
我们需要从不同的角度思考问题

2
00:00:01,890 --> 00:00:05,747
我们没有一个合理的基本情况 来得出好的递归定义

3
00:00:05,747 --> 00:00:08,630
我们将转而使用松弛算法

4
00:00:08,630 --> 00:00:12,550
理论很简单

5
00:00:12,550 --> 00:00:15,670
我们将从一个猜测开始

6
00:00:15,670 --> 00:00:19,270
然后进行某种循环 直接写为

7
00:00:19,270 --> 00:00:21,420
如果我们还未完成 我们将弄清楚如何判断是否已完成

8
00:00:21,420 --> 00:00:24,070
我们将采取某种操作使猜测更准确

9
00:00:25,270 --> 00:00:28,260
基础理论就是这样 我们没有好的停止点

10
00:00:28,260 --> 00:00:31,260
我们没有一个清晰的起始点

11
00:00:31,260 --> 00:00:34,050
不能假设 Alice 的受欢迎程度是 1 然后接着定义

12
00:00:34,050 --> 00:00:36,858
我们将先从一个猜测开始

13
00:00:36,858 --> 00:00:40,290
我们的猜测是 假设所有人的初始受欢迎程度都是 1

14
00:00:40,290 --> 00:00:44,270
然后不断完善猜测

15
00:00:44,270 --> 00:00:47,740
我们有一个流程 根据所得出的结论更新猜测

16
00:00:47,740 --> 00:00:50,130
每次进行这个流程 我们的猜测就越来越准确

17
00:00:51,130 --> 00:00:53,195
最终将会停止

18
00:00:53,195 --> 00:00:56,380
并得出我们想要的结果

19
00:00:56,380 --> 00:00:58,390
我们看看如何这么计算受欢迎程度得分

20
00:00:58,390 --> 00:01:02,590
现在 popularity 有 2 个输入 而不是 1 个

21
00:01:02,590 --> 00:01:04,750
它将传入步骤数

22
00:01:04,750 --> 00:01:08,470
即我们已经尝试猜测过的次数

23
00:01:08,470 --> 00:01:12,482
并传入相关的人名

24
00:01:12,482 --> 00:01:16,310
输出依然为得分 现在可以定义成

25
00:01:16,310 --> 00:01:18,270
我们的确有一个起始点

26
00:01:18,270 --> 00:01:21,870
就相当于在递归定义中有一个停止点

27
00:01:21,870 --> 00:01:26,020
我们将定义第 0 步时的值

28
00:01:26,020 --> 00:01:30,245
对任何人来说 我们都假设得分是 1

29
00:01:30,245 --> 00:01:33,240
我们没有成功获取基本情况

30
00:01:33,240 --> 00:01:35,460
当只有 person 参数的时候 因为人们没有清晰的顺序

31
00:01:35,460 --> 00:01:38,050
我们有一个图 其中有很多不同的友谊连接

32
00:01:38,050 --> 00:01:41,490
没有清晰的起始点 我们将添加

33
00:01:41,490 --> 00:01:43,820
一个额外的参数 即步骤数

34
00:01:43,820 --> 00:01:46,000
这将是我们的基本情况

35
00:01:46,000 --> 00:01:47,860
如果将步骤数考虑到基本情况中

36
00:01:47,860 --> 00:01:51,740
那么就可以说步骤 0 是我们的基本情况

37
00:01:51,740 --> 00:01:54,570
在步骤 0 时 我们说所有人的受欢迎程度得分是 1

38
00:01:54,570 --> 00:01:58,190
现在就可以得出更新规则了

39
00:01:58,190 --> 00:02:01,390
我们可以得出在任意步骤 t

40
00:02:01,390 --> 00:02:05,310
(其中 t>0) 任何人的受欢迎程度

41
00:02:06,470 --> 00:02:09,710
我们将其定义为所有好友的累加值

42
00:02:09,710 --> 00:02:11,936
我们将从好友集合中

43
00:02:11,936 --> 00:02:16,266
选择一个好友

44
00:02:16,266 --> 00:02:20,170
我们将计算每个好友的受欢迎程度得分之和

45
00:02:20,170 --> 00:02:26,145
我们将使用步骤 t-1 而不是步骤 t

46
00:02:26,145 --> 00:02:28,330
也就是说我们要计算

47
00:02:28,330 --> 00:02:32,180
上一步骤的好友受欢迎程度

48
00:02:32,180 --> 00:02:34,650
我们将使用该值来计算

49
00:02:34,650 --> 00:02:39,100
在此步骤中的好友受欢迎程度

50
00:02:39,100 --> 00:02:42,890
我用伪代码来表示

51
00:02:42,890 --> 00:02:44,810
如果将此看做 Python 过程

52
00:02:44,810 --> 00:02:46,840
我们将传入两个输入

53
00:02:46,840 --> 00:02:51,900
步骤和人名

54
00:02:51,900 --> 00:02:53,770
现在有了基本情况

55
00:02:53,770 --> 00:02:57,450
如果步骤是 0 我们将返回始终为 1 的得分

56
00:02:57,450 --> 00:03:02,420
如果步骤不是 0 则得分计算方法和之前的相似

57
00:03:02,420 --> 00:03:04,990
我们将初始化 score 为 0

58
00:03:04,990 --> 00:03:08,500
我们将对好友求和

59
00:03:08,500 --> 00:03:13,020
通过加上上一步骤的好友受欢迎程度得分

60
00:03:13,020 --> 00:03:16,880
更新 score 循环完成后

61
00:03:16,880 --> 00:03:19,770
score 的值就是结果

62
00:03:19,770 --> 00:03:22,640
现在我们拥有了新的定义

63
00:03:22,640 --> 00:03:25,030
上面是数学符号的定义

64
00:03:25,030 --> 00:03:27,440
这里是 Python 代码 问题是

65
00:03:27,440 --> 00:03:30,120
这是好的递归定义吗？我并不是问

66
00:03:30,120 --> 00:03:32,410
这是否是好的受欢迎程度定义 希望不是

67
00:03:33,620 --> 00:03:36,150
我想问的是 对于所有可能的输入

68
00:03:36,150 --> 00:03:38,070
对于所有传入的 t 和 p 值

69
00:03:38,070 --> 00:03:41,610
我们定义受欢迎程度的方式能给出结果吗？

70
00:03:41,610 --> 00:03:47,640
选项如下 选项 1 Yes

71
00:03:47,640 --> 00:03:50,950
选项 2 仅当人们无法与自己是好友时才是一个好定义

72
00:03:50,950 --> 00:03:53,850
选项 3 仅当所有人都至少有 1 个好友时才是一个好定义

73
00:03:53,850 --> 00:03:57,010
希望大家都至少有 1 个好友

74
00:03:57,010 --> 00:04:01,420
或者 仅当所有人都比 Alice 更受欢迎时才是一个好定义
