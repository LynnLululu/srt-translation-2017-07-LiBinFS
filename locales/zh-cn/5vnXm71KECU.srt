1
00:00:00,530 --> 00:00:03,330
因此 答案是前三个都是很好的原因

2
00:00:03,330 --> 00:00:07,160
关于为什么专注于时间长度与输入的规模 而不是

3
00:00:07,160 --> 00:00:11,980
绝对时间 因此第一个原因是 如果我们了解

4
00:00:11,980 --> 00:00:14,840
根据输入大小的时间消耗 那么我们可以

5
00:00:14,840 --> 00:00:17,870
在实际执行程序之前预测需要多长时间

6
00:00:17,870 --> 00:00:19,950
如果我们必须运行程序来确定需要多长时间

7
00:00:19,950 --> 00:00:23,050
那就没什么用了 因为我们其实已经

8
00:00:23,050 --> 00:00:25,560
做完了 我们已经得到了我们想要的结果 如果我们只

9
00:00:25,560 --> 00:00:28,260
知道这个特定输入需要多长时间 我们

10
00:00:28,260 --> 00:00:30,960
得不到什么有用的信息

11
00:00:30,960 --> 00:00:33,170
关于在其他输入上运行 它需要花费的时间 所以我们

12
00:00:33,170 --> 00:00:36,060
希望能够作出预测 通过了解运行时间如何

13
00:00:36,060 --> 00:00:38,860
依赖于输入的实际大小

14
00:00:38,860 --> 00:00:42,200
第二个原因也是如此 通过了解时间与

15
00:00:42,200 --> 00:00:44,230
输入大小的关系 我们可以更好地了解

16
00:00:44,230 --> 00:00:48,100
成本随时间的变化 计算机会越来越便宜 速度会越来越快

17
00:00:48,100 --> 00:00:51,110
— 戈登·摩尔 (Gordon Moore) 在1965年观察到这一点

18
00:00:51,110 --> 00:00:54,720
现在我们有时称之为摩尔定律的概念

19
00:00:54,720 --> 00:00:57,320
这不是物理规律意义上的定律

20
00:00:57,320 --> 00:00:59,700
但它是一个定律 计算机历史

21
00:00:59,700 --> 00:01:02,600
一直遵循这一趋势 其中 以相同的成本

22
00:01:02,600 --> 00:01:06,150
获得的计算能力大约每18个月增加一倍

23
00:01:06,150 --> 00:01:10,650
1,000美元在今天可以获得的是

24
00:01:10,650 --> 00:01:12,920
在一年半后可以获得的一半

25
00:01:12,920 --> 00:01:16,190
这是一个相当不错的特性

26
00:01:16,190 --> 00:01:18,990
但它意味着 了解今天的成本

27
00:01:18,990 --> 00:01:21,430
并没有告诉我们什么 我们真正想了解的是

28
00:01:21,430 --> 00:01:24,460
更根本的成本 第三个

29
00:01:24,460 --> 00:01:28,510
原因也是对的 通过了解时间

30
00:01:28,510 --> 00:01:31,640
与输入大小的关系 我们得到对算法更好更根本的

31
00:01:31,640 --> 00:01:34,810
了解 比起我们只对几个不同的输入

32
00:01:34,810 --> 00:01:37,450
绝对时间的测量 第四个答案是

33
00:01:37,450 --> 00:01:41,050
不正确的 抽象答案可能与具体答案一样错误

34
00:01:41,050 --> 00:01:43,670
但是 拥有好的抽象答案将使我们了解

35
00:01:43,670 --> 00:01:46,950
事情变得更深入 比起几个特定的具体答案

