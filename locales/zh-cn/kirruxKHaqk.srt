1
00:00:01,230 --> 00:00:04,270
任何过程我们都可以使用递归编写 我们也可以

2
00:00:04,270 --> 00:00:07,430
不使用递归定义来编写 我要

3
00:00:07,430 --> 00:00:09,760
展示给你另一种方式来定义 我们之前定义过的

4
00:00:09,760 --> 00:00:12,620
回文 那么在这里 我们使用 for 循环

5
00:00:12,620 --> 00:00:16,340
然后我们使用变量 i 循环 范围

6
00:00:16,340 --> 00:00:19,200
从 0 到 s 的长度除以 2

7
00:00:19,200 --> 00:00:23,630
也就是遍历字符串 s 的一半 在循环内部

8
00:00:23,630 --> 00:00:26,500
我们有一个 if 测试来检查 是否

9
00:00:26,500 --> 00:00:30,740
位置 i 上的字符与位置 -(i+1) 上的不同

10
00:00:30,740 --> 00:00:33,220
这将从字符串后面计数

11
00:00:33,220 --> 00:00:37,320
i 个位置 如果它们不同

12
00:00:37,320 --> 00:00:40,420
那么 我们已经发现不匹配 我们返回 False 如果它们

13
00:00:40,420 --> 00:00:42,900
没有不同 我们将继续循环下去 一旦

14
00:00:42,900 --> 00:00:44,495
我们到循环结束还没有找到任何

15
00:00:44,495 --> 00:00:48,380
不同 我们就知道这是一个回文 我们返回 True

16
00:00:48,380 --> 00:00:51,510
所以 这也是另一种我们可以定义回文的方式

17
00:00:51,510 --> 00:00:54,210
我觉得这理解起来更复杂 并且更难

18
00:00:54,210 --> 00:00:58,210
做对 我尝试了三次才使代码正确运行

19
00:00:58,210 --> 00:01:02,250
而使用递归定义 我能第一次就正确完成

20
00:01:02,250 --> 00:01:05,450
如果我们想测试很长的回文 这将是

21
00:01:05,450 --> 00:01:07,720
更高效的 比起我们使用递归定义来说

22
00:01:07,720 --> 00:01:11,310
有几个原因 一个是

23
00:01:11,310 --> 00:01:14,410
递归定义不断创建新的字符串 每次我们

24
00:01:14,410 --> 00:01:17,080
进行递归调用 我们要创建一个新的字符串

25
00:01:17,080 --> 00:01:20,370
这是相当昂贵的 另一个原因是 递归调用

26
00:01:20,370 --> 00:01:24,230
本身就是相当昂贵的 有一些语言使得

27
00:01:24,230 --> 00:01:27,170
递归调用相当便宜 但是 Python 是不是其中之一

28
00:01:27,170 --> 00:01:30,980
在 Python 中 执行递归调用相当昂贵 所以

29
00:01:30,980 --> 00:01:33,970
对于大多数程序 递归的方式往往是最

30
00:01:33,970 --> 00:01:36,570
优雅、最简单的方法来获得正确结果 如果我们

31
00:01:36,570 --> 00:01:39,060
真的担心性能 我们需要程序来处理

32
00:01:39,060 --> 00:01:42,340
真正大的输入 我们通常最好尝试找到

33
00:01:42,340 --> 00:01:44,550
一种非递归的方式来定义该过程

