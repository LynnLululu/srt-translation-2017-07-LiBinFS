1
00:00:00,090 --> 00:00:03,370
那么答案是 只有第2个和第3个

2
00:00:03,370 --> 00:00:06,360
是相等的 这令人感到有点惊讶 这是

3
00:00:06,360 --> 00:00:09,646
一个有些棘手的问题 那么第一个不相等的原因

4
00:00:09,646 --> 00:00:13,430
是 如果 x 是 7 或更大 那么

5
00:00:13,430 --> 00:00:16,750
7 % 7 的值是0 这与我们

6
00:00:16,750 --> 00:00:19,580
一开始的 x 的值不相等 然后 这是

7
00:00:19,580 --> 00:00:22,469
x 为 8 的情况 8 % 7

8
00:00:22,469 --> 00:00:25,300
的值为 1 也与我们一开始的值不同

9
00:00:26,460 --> 00:00:29,190
当取模的对象比 x 可能的值要大的时候

10
00:00:29,190 --> 00:00:31,840
而且我们说过 x 只可能在 0 到

11
00:00:31,840 --> 00:00:34,300
10 之间 那么 结果会总是与 x 相同

12
00:00:34,300 --> 00:00:39,590
第三个问题 当我们映射 x 到它对应的字符

13
00:00:39,590 --> 00:00:41,810
值 然后我们取这个字符的序号 我们将

14
00:00:41,810 --> 00:00:46,020
转换这个字符为它对应的序号 所以这是相等的 你会认为

15
00:00:46,020 --> 00:00:48,570
在另一个方向上也对 但是它不对 原因是

16
00:00:48,570 --> 00:00:52,200
因为 ord 的输入必须是一个单字符的字符串

17
00:00:52,200 --> 00:00:55,210
如果输入的不是一个单一的字符 那么 ord 会生成

18
00:00:55,210 --> 00:00:58,410
一个错误 那么让我们在 Python 解释器中看看 如果

19
00:00:58,410 --> 00:01:02,500
我们打印 ord 的结果 其中输入是一个

20
00:01:02,500 --> 00:01:04,980
数字 而且我们说过 x 是 0 到 3 之间的数 ( 此处口误应为 0 到 10 之间 )

21
00:01:04,980 --> 00:01:07,840
好了 它给了我们一个错误 它之所以给出

22
00:01:07,840 --> 00:01:10,280
错误 是因为 ord 期望的输入是长度为 1 的字符串 但

23
00:01:10,280 --> 00:01:13,440
这个输入是一个整数 有一种方法 允许我们

24
00:01:13,440 --> 00:01:17,390
把数字转换成字符串 而这正是 str 方法

25
00:01:17,390 --> 00:01:21,260
传入一个数字 给到我们该数字对应的

26
00:01:21,260 --> 00:01:24,460
字符串 那么 让我们看看 str(3)

27
00:01:24,460 --> 00:01:26,820
给到我们什么 这会给我们字符串 3

28
00:01:26,820 --> 00:01:28,720
我们不能在输出这里看出它实际上是

29
00:01:28,720 --> 00:01:31,230
一个字符串 但它确实是一个字符串 然后我们

30
00:01:31,230 --> 00:01:35,070
实际上可以对这个结果使用 ord 当我们

31
00:01:35,070 --> 00:01:39,430
运行它 我们得到的是51 而不是

32
00:01:39,430 --> 00:01:43,070
我们传入进去的 3 这是因为

33
00:01:43,070 --> 00:01:46,945
ord 字符串 3 的值是 51

