1
00:00:00,150 --> 00:00:02,220
这是一个很难的问题 如果你不能

2
00:00:02,220 --> 00:00:05,350
自己解答 这也没关系 我鼓励你可以在

3
00:00:05,350 --> 00:00:08,090
解答视频的中途暂停 一旦你理解了使你

4
00:00:08,090 --> 00:00:11,850
困惑的部分 然后再看看是否可以独自实现它

5
00:00:11,850 --> 00:00:14,330
我们要做的是定义一个函数 我们将

6
00:00:14,330 --> 00:00:18,980
定义一个 hash_string 函数 它有两个输入 关键词和

7
00:00:18,980 --> 00:00:22,330
桶的数目 我们将记录我们在圆内的位置

8
00:00:22,330 --> 00:00:25,640
为了实现它 我们需要引入一个新的变量　

9
00:00:25,640 --> 00:00:28,780
并且我们应当从位置 0 开始 我们将初始化那个变量

10
00:00:28,780 --> 00:00:31,790
我们使用 h 代表该哈希 我们将其初始化为 0

11
00:00:31,790 --> 00:00:34,260
现在我们要遍历关键词中的

12
00:00:34,260 --> 00:00:37,300
所有字母 所以我们将有一个 for 循环

13
00:00:37,300 --> 00:00:40,650
遍历关键词中的每个字母 对于每一个字母 我们

14
00:00:40,650 --> 00:00:42,960
把它加到哈希中 我们将把

15
00:00:42,960 --> 00:00:46,928
那个字母的值加到 h 我们可以在这里

16
00:00:46,928 --> 00:00:51,730
进行模运算 所以我们可以在这里对 buckets 取模

17
00:00:51,730 --> 00:00:53,660
我们必须小心这里的括号 如果我们

18
00:00:53,660 --> 00:00:57,365
只是这部分对 buckets 取模 我们不会得到正确的结果

19
00:00:57,365 --> 00:00:59,690
因为它实际计算的是 ord(c) % buckets 但是我们真正

20
00:00:59,690 --> 00:01:03,460
需要的是 h 与 ord(c) 之和 对 buckets 取模

21
00:01:03,460 --> 00:01:06,380
最后我们会返回哈希值

22
00:01:06,380 --> 00:01:10,280
我们可以不用每次都做模运算

23
00:01:10,280 --> 00:01:12,970
可以只在最后做一次模运算 这将会

24
00:01:12,970 --> 00:01:16,640
计算一个很大的数字 如果我们有一个很长的字符串 然后

25
00:01:16,640 --> 00:01:20,610
在最后计算对 buckets 取模 两种方法都是可行的

26
00:01:20,610 --> 00:01:22,820
这种方法更好一点 因为如果我们的

27
00:01:22,820 --> 00:01:25,520
字符串很长 我们不得不计算一个很大

28
00:01:25,520 --> 00:01:28,230
很大的数字 这样的代价更昂贵

29
00:01:28,230 --> 00:01:31,790
甚至有可能崩溃 如果它是一个超级长的关键词

30
00:01:31,790 --> 00:01:34,490
所以在这里进行模运算更好 尽管我们可以获得

31
00:01:34,490 --> 00:01:38,300
相同的结果 让我们在 Python 解释器里尝试一下

32
00:01:38,300 --> 00:01:41,990
这是我们在画板里实现的代码

33
00:01:41,990 --> 00:01:44,980
我们有变量 h 用来记录

34
00:01:44,980 --> 00:01:46,650
哈希值 我们将遍历关键词里的

35
00:01:46,650 --> 00:01:49,550
所有字母 并把每一个加到哈希值

36
00:01:49,550 --> 00:01:53,800
最后对桶数目取模 让我们试一些例子

37
00:01:56,820 --> 00:01:59,890
对于 a 字符 桶数目为 12 哈希到桶 1

38
00:01:59,890 --> 00:02:04,590
和期望的一样 再看看 b 哈希

39
00:02:04,590 --> 00:02:08,008
到桶 2 也是我们期望的 那么另一个

40
00:02:08,008 --> 00:02:10,320
我们应该尝试的是 如果你记得 当我们使用

41
00:02:10,320 --> 00:02:13,530
bad_hash_string 函数的时候 它的众多问题之一是

42
00:02:13,530 --> 00:02:15,890
它并不是对所有字符串都有效 尤其是

43
00:02:15,890 --> 00:02:18,690
对空字符串无效 你认为我们这里的 hash_string 函数

44
00:02:18,690 --> 00:02:21,920
对空字符串是否有效呢？尝试猜想一下

45
00:02:21,920 --> 00:02:24,440
结果 在我运行程序之前 然后我

46
00:02:24,440 --> 00:02:27,730
将运行它 你可以看到结果是 0 没有报错

47
00:02:27,730 --> 00:02:30,230
结果为 0 是可以讲得通的

48
00:02:30,230 --> 00:02:32,700
我们 h 初始为 0 当字符串没有字符的时候

49
00:02:32,700 --> 00:02:35,130
我们根本不会执行这段 for 循环 所以

50
00:02:35,130 --> 00:02:38,360
当我们返回时 h 依旧是 0 让我们也尝试一下更长的

51
00:02:38,360 --> 00:02:43,800
例子 我们对 udacity 在桶数目为 12 下哈希 我们得到

52
00:02:43,800 --> 00:02:47,440
桶 11 我们应当可以增加桶的数目

53
00:02:47,440 --> 00:02:51,500
所以让我们增加桶数目 假设我们有 1000 个桶

54
00:02:52,580 --> 00:02:57,670
我们得到桶 755 这还不足以使我们相信我们的 hash_string

55
00:02:57,670 --> 00:03:00,650
函数 将所有的字符串都良好地分布在了

56
00:03:00,650 --> 00:03:02,390
所有的桶中 但是至少我们得到了一个

57
00:03:02,390 --> 00:03:06,070
相当大的数字 表明我们可能使用了所有的桶
