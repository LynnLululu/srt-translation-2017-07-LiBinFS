1
00:00:01,020 --> 00:00:03,400
这是一个非常困难的问题 而且我承认

2
00:00:03,400 --> 00:00:06,340
在试图回答这个问题时 我自己也错了两次 但是

3
00:00:06,340 --> 00:00:08,640
现在我可以肯定自己知道正确答案 那就是

4
00:00:08,640 --> 00:00:13,150
其实这些都不等同于 s.find(t,i) 如果你没有

5
00:00:13,150 --> 00:00:15,990
做对 没关系 其中有两个选项是非常接近的

6
00:00:15,990 --> 00:00:18,580
就是选项一和选项三

7
00:00:18,580 --> 00:00:21,350
但他们都不是完全正确的 让我们通过

8
00:00:21,350 --> 00:00:26,580
一个例子来理解 让我们假设初始化 s 为

9
00:00:26,580 --> 00:00:32,330
udacity 初始化 t 为 city

10
00:00:32,330 --> 00:00:38,110
初始化 i 为 3

11
00:00:38,110 --> 00:00:42,857
如果我们执行 s.find(t,i)

12
00:00:42,857 --> 00:00:48,008
就是从 i 位置 也就是 (c) 在 s 中寻找 city

13
00:00:48,008 --> 00:00:53,056
然后我们发现它在那里 s.find(t,i) 的输出

14
00:00:53,056 --> 00:00:57,120
在这些变量的情况下是 3

15
00:00:57,120 --> 00:00:59,600
它从位置3开始搜索 但它仍然

16
00:00:59,600 --> 00:01:01,700
将给我们输出 位置3

17
00:01:01,700 --> 00:01:04,090
它给我们输出的位置 是对于

18
00:01:04,090 --> 00:01:09,190
原始的字符串 s 来说的 所以 选项一 s[i:] 其中

19
00:01:09,190 --> 00:01:12,940
i 是 3 字符串将会变成这样 所以当我们

20
00:01:12,940 --> 00:01:15,620
对这个字符串进行查找的时候 我们发现 city

21
00:01:15,620 --> 00:01:18,220
在位置 0 最终结果为 0

22
00:01:18,220 --> 00:01:20,780
这与我们期望的结果不符

23
00:01:20,780 --> 00:01:24,570
结果应该是3 选项二实际上

24
00:01:24,570 --> 00:01:29,180
没有任何意义 在这里 s.find(t) 为一个数字

25
00:01:29,180 --> 00:01:31,890
然后我们试图从一个数字中进行索引

26
00:01:31,890 --> 00:01:34,160
那没有任何意义 我们只能从字符串索引

27
00:01:34,160 --> 00:01:37,590
选择这个字符串的子序列 而没有办法

28
00:01:37,590 --> 00:01:40,120
从一个数字中选择子序列

29
00:01:40,120 --> 00:01:43,300
所以这是无效的 绝对产生不了相同的输出

30
00:01:43,300 --> 00:01:49,100
与 s.find(t,i) 相比 选项三是最棘手的 这个选项

31
00:01:49,100 --> 00:01:53,590
我本来以为会是相等的 因为这种特定情况

32
00:01:53,590 --> 00:01:58,530
这种情况下 当我们运行 s[i:].find(t)

33
00:01:58,530 --> 00:02:00,730
产生结果为 0 像我们刚才看到的那样

34
00:02:00,730 --> 00:02:02,925
当我们把 i 的值加上去

35
00:02:02,925 --> 00:02:05,120
我们就可以得到结果 3 因此

36
00:02:05,120 --> 00:02:08,350
可以在 s 的 i 位置后找到 t 的情况下

37
00:02:08,350 --> 00:02:14,358
这将是相等的 如果我们赋值给 t 其他值

38
00:02:14,358 --> 00:02:20,742
假设我们使 t 成为 dog 那结果将是什么

39
00:02:20,742 --> 00:02:28,600
s.find(t,i) 当 t 是 dog 时 结果是 -1

40
00:02:28,600 --> 00:02:33,606
当我们在字符串中找不到目标时 总会返回 -1

41
00:02:33,606 --> 00:02:36,246
在这种情况下 我们得到这个的结果为 -1

42
00:02:36,246 --> 00:02:38,710
然后将 i 的值加上去 这将给我们

43
00:02:38,710 --> 00:02:41,570
数字 2 这跟 -1 是不相同的

44
00:02:41,570 --> 00:02:44,790
因此这个也是不等价的

45
00:02:44,790 --> 00:02:47,420
在 t 可以找到的时候是相等的 但在

46
00:02:47,420 --> 00:02:50,620
t 没有找到的情况下不是相等的 选项四也是

47
00:02:50,620 --> 00:02:55,310
不等价的 对于选项四 我们开始

48
00:02:55,310 --> 00:02:58,810
选择了 s 的子序列 从位置 i 开始

49
00:02:58,810 --> 00:03:04,070
我们寻找字符串 t 的子序列 (从 t 的位置 i 开始选择)

50
00:03:04,070 --> 00:03:08,960
这不会给我们与 s.find(t,i) 同样的结果 所以

51
00:03:08,960 --> 00:03:11,420
这是一个棘手的问题 如果你没有做对 不要难过

52
00:03:11,420 --> 00:03:16,746
答案是实际上没有一个选项等同于 s.find(t,i)

