1
00:00:00,620 --> 00:00:04,410
接下来就是定义回文过程的一种方法 我们需要

2
00:00:04,410 --> 00:00:06,580
输入一个字符串 我把它叫做 s 

3
00:00:07,700 --> 00:00:10,030
然后我们首先进行基本情况的判断 所以

4
00:00:10,030 --> 00:00:13,870
基本情况就是当输入的字符串为空字符串时  我们

5
00:00:13,870 --> 00:00:16,350
应该马上返回逻辑真的结果 所以我们可以

6
00:00:16,350 --> 00:00:19,460
用 if 语句实现判断 我们将检验 s 是否等于  

7
00:00:19,460 --> 00:00:23,100
空字符串 如果它等于空字符串的话 我们就返回逻辑真的值

8
00:00:23,100 --> 00:00:25,730
这就是基本情况的 if 子句部分 对于 else 子句部分 我们要开始递归情况的判断

9
00:00:25,730 --> 00:00:30,360
所以我们现在需要进行字符串第一个字符和最后一个字符的测试

10
00:00:30,360 --> 00:00:32,600
看它们的值是否相等 我们可以实现它

11
00:00:32,600 --> 00:00:35,960
通过字符串的索引操作符  我们可以从 s[0] 得到

12
00:00:35,960 --> 00:00:40,080
字符串的第一个字符  s[-1] 可以为我们取得

13
00:00:40,080 --> 00:00:44,330
字符串的最后一个字符 如果这两个字符相等的话 那我们需要

14
00:00:44,330 --> 00:00:47,490
测试字符串的剩余部分 如果它们不相等的话

15
00:00:47,490 --> 00:00:50,610
让我们先完成不符合以上情况时的代码

16
00:00:50,610 --> 00:00:52,950
所以如果它们不相等 我们就知道它不是

17
00:00:52,950 --> 00:00:55,140
回文 因为我们发现了第一个字符

18
00:00:55,140 --> 00:00:57,880
和最后一个字符不相等的情况 所以该过程应该返回

19
00:00:57,880 --> 00:01:01,680
逻辑假的值 如果它们相等的话 那么我们就有

20
00:01:01,680 --> 00:01:04,769
更困难的问题要解决 我们需要进行递归调用

21
00:01:04,769 --> 00:01:07,690
校验字符串中的其他所有字符是否仍然

22
00:01:07,690 --> 00:01:12,170
属于回文 这是我们的初始字符串 它由

23
00:01:12,170 --> 00:01:16,170
这么多字符组成 我们已经测试了这个字符是否

24
00:01:16,170 --> 00:01:20,610
匹配这个字符 现在我们要做的是对字符串剩余部分进行校验

25
00:01:20,610 --> 00:01:22,980
判断剩余部分是否构成回文 这将是一个

26
00:01:22,980 --> 00:01:26,662
递归调用 所以我们将返回这样的结果

27
00:01:26,662 --> 00:01:30,850
也就是调用 is_palindrome 过程本身 但不同于输入字符串 s 的是 我们

28
00:01:30,850 --> 00:01:33,590
要输入的是 s[1:-1] 子串

29
00:01:33,590 --> 00:01:37,085
也就是移去第一个字符

30
00:01:37,085 --> 00:01:41,890
然后以 -1 作结尾 也就是移去最后一个字符

31
00:01:41,890 --> 00:01:44,604
要记住我们索引的用法 这里的最后一个字符 s[-1] 是不包括在内的

32
00:01:44,604 --> 00:01:47,735
所以这里的最后一个索引值取 -1

33
00:01:47,735 --> 00:01:50,570
它就移去了字符串的最后一个字符 

34
00:01:50,570 --> 00:01:54,230
我们首先要测试的是基本情况的判断

35
00:01:54,230 --> 00:01:57,330
我们输入空字符串 而空字符串

36
00:01:57,330 --> 00:01:59,470
属于回文 所以这个过程应该返回给我们的值是

37
00:01:59,470 --> 00:02:03,340
逻辑真 结果正是如此 让我们尝试一下单字符的字符串

38
00:02:03,340 --> 00:02:07,650
a 它也是回文 正反向读都是同一个字符 

39
00:02:07,650 --> 00:02:13,250
然后我们也是得到逻辑真的结果 如果我们尝试输入 ab 字符串的话 也就是不属于

40
00:02:13,250 --> 00:02:19,065
回文 我们得到了逻辑假的结果 做更长字符的测试 如果我们

41
00:02:19,065 --> 00:02:25,070
尝试输入 level 我们应该得到逻辑真的结果 结果正确 然后我们尝试

42
00:02:25,070 --> 00:02:31,440
最著名的一个回文 amanaplanacanalpanama

43
00:02:32,730 --> 00:02:35,330
然后我们应该得到逻辑真的值 结果正是如此

44
00:02:35,330 --> 00:02:39,050
[无声音]
