1
00:00:00,320 --> 00:00:03,490
这里是定义 hashtable_lookup 的一种方式 那么我们要获取

2
00:00:03,490 --> 00:00:06,540
表和键 然后第一步是

3
00:00:06,540 --> 00:00:09,960
找到对应的桶 所以我们将使用我们之前定义的 hashtable_get_bucket

4
00:00:09,960 --> 00:00:13,140
并将其存储在一个称为 bucket 的变量中

5
00:00:13,140 --> 00:00:17,110
所以我们将使用 hashtable_get_bucket 查找 key 将出现在

6
00:00:17,110 --> 00:00:19,930
这个哈希表中的哪里 我们将它存储在 bucket 里面

7
00:00:19,930 --> 00:00:21,530
但是现在要做查找 我们需要遍历

8
00:00:21,530 --> 00:00:25,660
桶中的所有条目 找到一个匹配的键

9
00:00:25,660 --> 00:00:27,360
要进行查找 我们需要遍历存储桶中的

10
00:00:27,360 --> 00:00:29,502
所有条目 因此 我们将使用一个 for 循环

11
00:00:29,502 --> 00:00:33,540
遍历所有条目 对于每个条目 我们要检查

12
00:00:33,540 --> 00:00:36,950
该条目的键部分是否与 key 相匹配 然后记住

13
00:00:36,950 --> 00:00:40,430
桶是一个条目列表 桶中的每个条目

14
00:00:40,430 --> 00:00:44,720
都是该值中的一个关键词 在我们的网络抓取工具的情况下

15
00:00:44,720 --> 00:00:47,880
值是 URL 的列表 因此 如果该条目

16
00:00:47,880 --> 00:00:50,870
与 key 相匹配 条目的第一部分是

17
00:00:50,870 --> 00:00:53,760
关键词 如果与我们正在寻找的 key 相匹配 那么

18
00:00:53,760 --> 00:00:57,080
我们要做的是返回该值 所以结果是

19
00:00:57,080 --> 00:01:00,600
entry[1] 如果不匹配 那么我们

20
00:01:00,600 --> 00:01:02,790
要继续前进 继续在下一个尝试 我们将继续遍历

21
00:01:02,790 --> 00:01:06,450
这个 for 循环 检查桶中的所有条目

22
00:01:06,450 --> 00:01:08,870
当我们到了最后 没有发现它

23
00:01:08,870 --> 00:01:10,400
我们在问题说的是 如果它不在

24
00:01:10,400 --> 00:01:13,990
表中 我们应该做的是输出 None 所以现在我们会返回

25
00:01:16,320 --> 00:01:20,440
值 None 那么让我们在 Python 解释器中尝试一下

26
00:01:20,440 --> 00:01:24,170
所以这里是代码 我们正在定义一个 hashtable_lookup 我们找到桶

27
00:01:24,170 --> 00:01:26,480
我们循环遍历桶中的所有条目 如果我们

28
00:01:26,480 --> 00:01:29,680
找到一个匹配的键 我们返回与之关联的值

29
00:01:29,680 --> 00:01:32,560
否则我们返回 None 当我们到了

30
00:01:32,560 --> 00:01:35,290
桶的末端仍然没有发现匹配的条目 我们知道它不可能

31
00:01:35,290 --> 00:01:38,090
在哈希表中的其他地方存在 因为关键词

32
00:01:38,090 --> 00:01:41,320
可能出现的唯一地方是在这个桶里 我们仍然拥有

33
00:01:41,320 --> 00:01:43,870
与之前相同的所有代码 这使得哈希表可以获取到

34
00:01:43,870 --> 00:01:47,160
桶 然后添加到表中 然后 我们将对其进行测试

35
00:01:47,160 --> 00:01:49,730
使用一些我们以前写的代码 我们要添加

36
00:01:49,730 --> 00:01:53,140
几个词给我们的哈希表 让我们尝试寻找一个

37
00:01:53,140 --> 00:01:57,370
关键词 我们将查找 udacity 而我们得到的值是 23

38
00:01:57,370 --> 00:02:01,140
这是我们所期望的 这是我们与 udacity 相关的值

39
00:02:01,140 --> 00:02:03,408
那么这看起来相当好 我们几乎使我们的

40
00:02:03,408 --> 00:02:06,490
哈希表工作了 我们之前提到的一个问题

41
00:02:06,490 --> 00:02:09,250
如果我们试图更改

42
00:02:09,250 --> 00:02:11,320
与 udacity 相关的值 我们将需要

43
00:02:11,320 --> 00:02:15,680
对我们的网络索引这样做 对吧？当我们将所有的网址添加到表

44
00:02:15,680 --> 00:02:19,786
我们需要不断增加网址 我们不希望失去我们拥有的任何一个 但我们

45
00:02:19,786 --> 00:02:21,979
要改变与该关键词相关联的值

46
00:02:21,979 --> 00:02:24,710
现在 我们再次查找 然后

47
00:02:26,750 --> 00:02:29,010
我们得到了相同的结果 其原因是

48
00:02:29,010 --> 00:02:31,740
如果我们看一下哈希表中的

49
00:02:31,740 --> 00:02:35,140
与关键词 udacity 相关的桶 然后我们看到的是 它的一个

50
00:02:35,140 --> 00:02:38,690
两个元素的列表 而且由于我们实现添加的方式

51
00:02:38,690 --> 00:02:41,630
较新的一个将添加在列表的后面 由于我们

52
00:02:41,630 --> 00:02:46,290
定义查询的方式 它总是会找到它匹配的第一个

53
00:02:46,290 --> 00:02:48,980
它按照顺序遍历条目 第一个匹配后

54
00:02:48,980 --> 00:02:51,590
它就会返回值 所以 这就是为什么我们得到的值是 23

55
00:02:51,590 --> 00:02:53,810
所以我们几乎完成了 但我们必须

56
00:02:53,810 --> 00:02:56,240
进行另一个改变 我们想改变添加 (add) 使其

57
00:02:56,240 --> 00:02:59,640
更像更新 (update) 因此 我们要更新与该条目

58
00:02:59,640 --> 00:03:02,270
相关联的值 而不是添加新条目

