1
00:00:00,300 --> 00:00:02,490
更新 (Uptate) 是和查看 (lookup) 相当类似的

2
00:00:02,490 --> 00:00:05,210
那么 让我们通过复制代码开始 然后

3
00:00:05,210 --> 00:00:06,960
看看我们需要怎么去改变它 所以我们

4
00:00:06,960 --> 00:00:09,560
有 lookup 我们要改变它使之成为 Uptate

5
00:00:12,340 --> 00:00:16,360
现在将需要一个键和一个值作为输入 而不只是一个键

6
00:00:18,460 --> 00:00:21,030
但是 它不会返回任何东西 所以我们要删除

7
00:00:21,030 --> 00:00:25,095
return 语句 对 记住 Uptate 要做的全部就是修改

8
00:00:25,095 --> 00:00:29,070
条目的值 所以现在我们仍拥有我们为 lookup 做的

9
00:00:29,070 --> 00:00:32,110
我们仍然会获取桶 而这也是我们希望做到的

10
00:00:32,110 --> 00:00:34,360
我们要确保我们在正确的桶中

11
00:00:34,360 --> 00:00:36,650
更新值 我们仍然需要遍历桶中的条目

12
00:00:36,650 --> 00:00:40,200
来寻找是否会有一个匹配项 如果我们找到匹配项

13
00:00:40,200 --> 00:00:43,990
按照我们之前在 lookup 所做的 只是将其返回 而在 Uptate 中

14
00:00:43,990 --> 00:00:46,640
我们要做的是改变与这个键关联的值

15
00:00:46,640 --> 00:00:50,080
因此 我们将用一个赋值语句

16
00:00:50,080 --> 00:00:53,030
无论该值之前是什么 我们将其替换为一个新值 现在

17
00:00:53,030 --> 00:00:57,190
我们要停止循环 而不是返回该值

18
00:00:57,190 --> 00:00:59,770
我们实际上已经完成 Uptate 要做的了 所以我们可以

19
00:00:59,770 --> 00:01:03,690
回到这里 我们找到对应条目 我们更新了值 我们

20
00:01:03,690 --> 00:01:05,470
还需要处理我们没有发现条目的情况

21
00:01:05,470 --> 00:01:09,320
现在 我们已经遍历了循环足够的时间

22
00:01:09,320 --> 00:01:11,980
当它是一次查找操作时 我们只是返回 None 当它是

23
00:01:11,980 --> 00:01:14,530
一次更新操作时 当键不在表中 我们

24
00:01:14,530 --> 00:01:16,990
要做的是添加它 所以 现在我们要

25
00:01:16,990 --> 00:01:22,520
使用 append 操作来给桶添加新的条目 具有

26
00:01:22,520 --> 00:01:26,260
该键和该值 所以 这就是我们定义的 Uptate

27
00:01:26,260 --> 00:01:28,530
当然有很多其他的方法来做到这一点 还有一件

28
00:01:28,530 --> 00:01:31,090
你应该考虑的事情是 实际上这些

29
00:01:31,090 --> 00:01:34,150
看起来非常相似 对吧？我们复制了很多代码

30
00:01:34,150 --> 00:01:36,410
也许有一种方法来定义 Uptate 和 lookup

31
00:01:36,410 --> 00:01:38,530
我们不必有两份相同的代码

32
00:01:38,530 --> 00:01:41,230
来扫描整个桶寻找正确的条目

33
00:01:41,230 --> 00:01:44,840
我会将这个问题留下 作为本单元的一个习题

34
00:01:44,840 --> 00:01:46,740
现在我们很高兴 我们已经正确实现了

35
00:01:46,740 --> 00:01:50,920
Uptate 和 lookup 让我们来测试它们

36
00:01:50,920 --> 00:01:54,070
那么 我们之前做的 我们要将 add 替换为

37
00:01:54,070 --> 00:01:59,280
update 然后现在第二次 add 后实现的

38
00:01:59,280 --> 00:02:02,040
是我们添加了一个条目 但是我们

39
00:02:02,040 --> 00:02:05,360
永远不可能找到这个条目 因为它已有相同的关键字

40
00:02:05,360 --> 00:02:08,720
现在我们使用 update 第二次我们应该

41
00:02:08,720 --> 00:02:13,830
更新该值 然后我们会看到 lookup 现在

42
00:02:13,830 --> 00:02:17,290
对于第二次查找传出值 27 这样就对了

43
00:02:17,290 --> 00:02:19,500
第一次查找时值为 23 我们做了更新后

44
00:02:19,500 --> 00:02:21,670
我们得到了 27 我们可以看到 该桶

45
00:02:21,670 --> 00:02:24,920
仅包含一个条目 所以这很棒 我们完成了我们

46
00:02:24,920 --> 00:02:28,330
对哈希表的实现 我们做的 Uptate

47
00:02:28,330 --> 00:02:30,350
既可以为哈希表添加新值——如果它们还

48
00:02:30,350 --> 00:02:34,920
不存在——也可以改变已经存在的值

49
00:02:34,920 --> 00:02:38,260
我们可以做查询 查询使我们知道去哪里寻找

50
00:02:38,260 --> 00:02:41,460
去哪个桶查找键 如果它存在的话

51
00:02:41,460 --> 00:02:44,450
当键的数量提升的时候 这样处理有很高的价值

52
00:02:44,450 --> 00:02:47,740
只要我们相应增加桶的数量

53
00:02:47,740 --> 00:02:50,020
做更新和查找的时间都是不变的

54
00:02:50,020 --> 00:02:54,160
这意味着时间甚至不会随关键词数量的增加而增加

55
00:02:54,160 --> 00:02:57,120
只要我们增加桶的数量 所以 每个桶

56
00:02:57,120 --> 00:03:01,350
保持同样的大小 因为遍历桶中元素

57
00:03:01,350 --> 00:03:04,360
寻找匹配键是很昂贵的

