1
00:00:00,110 --> 00:00:02,880
所以正确答案是第二个 希望没有人选择

2
00:00:02,880 --> 00:00:06,070
第一个 我们通常都会尝试用简单的方式

3
00:00:06,070 --> 00:00:08,600
这个单元算是某种例外 那就是

4
00:00:08,600 --> 00:00:12,850
我们正在学习如何自己定义一个哈希表 尽管 Python 提供了

5
00:00:12,850 --> 00:00:15,200
字典类型 —— 我会在单元结尾的时候讲到

6
00:00:15,200 --> 00:00:18,920
这可以比我们自己做要简单得多 但我们真的

7
00:00:18,920 --> 00:00:21,910
希望通过自己建立哈希表来更多地了解计算机科学

8
00:00:21,910 --> 00:00:25,230
我们实际上并不需要使用它 因为有一个内置的

9
00:00:25,230 --> 00:00:28,000
类型效果更好 答案是

10
00:00:28,000 --> 00:00:30,600
第二个选项 原因如下

11
00:00:30,600 --> 00:00:34,800
当我们评估这个列表乘法 好了 我们有

12
00:00:34,800 --> 00:00:38,800
这个空列表 让我们这样画 然后我们

13
00:00:38,800 --> 00:00:41,410
创建一个新的列表 是这个列表的三次复制

14
00:00:41,410 --> 00:00:44,690
但它不是副本 而是三个指向

15
00:00:44,690 --> 00:00:47,260
所以 这里是新列表 它有三个元素

16
00:00:47,260 --> 00:00:51,270
这些元素中的每一个都指向同一个空列表

17
00:00:51,270 --> 00:00:54,658
然后当我们对 table[1] 做追加 那么

18
00:00:54,658 --> 00:00:58,845
发生的事情是 我们按照这个指向 不管 table[1]

19
00:00:58,845 --> 00:01:02,330
是什么 我们将这个对象追加到它 增加一个

20
00:01:02,330 --> 00:01:05,760
新元素 但由于位置 0、1、2 的指向

21
00:01:05,760 --> 00:01:08,150
都指的是同一个对象 这改变了它们

22
00:01:08,150 --> 00:01:11,180
所有的值 而不是仅仅是 table[1] 的值

23
00:01:11,180 --> 00:01:12,670
我们可以看到 如果我们打印出

24
00:01:12,670 --> 00:01:16,310
整个表 该表包含三个元素 但它们都

25
00:01:16,310 --> 00:01:19,100
一样 它们都指代相同的对象

26
00:01:19,100 --> 00:01:21,490
因此 我们对其中一个任何变化都会改变它们

