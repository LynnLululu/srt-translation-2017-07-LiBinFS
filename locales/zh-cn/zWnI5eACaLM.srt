1
00:00:00,560 --> 00:00:03,110
我们开始练习另一个关于定义递归过程的例子

2
00:00:03,110 --> 00:00:05,870
这次我们的目标是输入

3
00:00:05,870 --> 00:00:09,260
一个字符串 然后决定它是否属于回文

4
00:00:09,260 --> 00:00:11,490
回文的概念是 阅读该字符串 它始终是同样的意思

5
00:00:11,490 --> 00:00:15,590
不管是正向还是逆向 现在我给出一个回文的例子

6
00:00:15,590 --> 00:00:19,040
就是 level 这个词 如果我们正向读 level 这个词 我们会得到

7
00:00:19,040 --> 00:00:22,130
level 这个词 如果我们反向读这个词 恰好得到的也是 level 这个词

8
00:00:22,130 --> 00:00:25,900
也就是同一个词 另一个属于回文的例子是这个词

9
00:00:25,900 --> 00:00:28,530
 we 单字母 a 如果我们正向去读这个词

10
00:00:28,530 --> 00:00:31,920
我们会得到 a  如果我们反向读呢 还是得到 a 这个词

11
00:00:31,920 --> 00:00:35,230
实际上 任何一个单字母肯定属于回文

12
00:00:35,230 --> 00:00:38,390
空字符也属于回文 如果我们

13
00:00:38,390 --> 00:00:41,520
正向去读空字符串 我们得到的是空字符串 如果

14
00:00:41,520 --> 00:00:45,310
我们反向读空字符串 我们也是得到一个空字符串

15
00:00:45,310 --> 00:00:48,001
所以我们的目标是定义一个过程 输入

16
00:00:48,001 --> 00:00:51,106
任何字符串 然后返回逻辑真的结果 如果

17
00:00:51,106 --> 00:00:54,040
输入的字符串是回文 我将会给你一些提示

18
00:00:54,040 --> 00:00:57,770
关于完成这个过程的提示 但是你要先自己思考 如果你能想出

19
00:00:57,770 --> 00:01:01,200
一种方式来定义测试输入字符串是否属于回文的过程

20
00:01:01,200 --> 00:01:04,542
这是一个相当难的问题 看一下你能

21
00:01:04,542 --> 00:01:07,134
通过自己的思考能想到哪一步 但是在提问前我将提供一些指示

22
00:01:07,134 --> 00:01:09,960
第一个指示是 我们要思考

23
00:01:09,960 --> 00:01:12,760
回文的概念是什么 我们要将这个概念形式化

24
00:01:12,760 --> 00:01:16,520
以及我们是否知道如何简单地生成输入字符串的反向形式

25
00:01:16,520 --> 00:01:18,480
随后再测试它与输入字符串是否相等 好 有这么一个简单的方法

26
00:01:18,480 --> 00:01:20,550
可以解决这个问题 实际上有很多方法可以完成这个任务

27
00:01:20,550 --> 00:01:23,420
在 Python 这门语言里 但是我们还没有接触过这些方法 而我想要

28
00:01:23,420 --> 00:01:26,610
让你想出判断回文的其他方式 而且不用依赖这些方法

29
00:01:26,610 --> 00:01:29,850
所以 我们需要思考出

30
00:01:29,850 --> 00:01:33,970
一种按照简单的方法去判断回文字符串的定义

31
00:01:33,970 --> 00:01:37,660
所以第一个要注意的点是 我们现在就知道有一个简单的情况

32
00:01:37,660 --> 00:01:41,700
用来判断字符串是否为回文 所以我们应该想出

33
00:01:41,700 --> 00:01:44,820
这就是我们递归定义中的基本情况 当我们执行

34
00:01:44,820 --> 00:01:48,320
关于数字处理的过程时 我们的基本情况经常是某些

35
00:01:48,320 --> 00:01:50,820
处理像 0 或者 1 这样的数字

36
00:01:50,820 --> 00:01:55,330
一个规模小的数字 当我们执行处理字符串的递归过程时

37
00:01:55,330 --> 00:01:57,340
那很可能我们的基本情况会是

38
00:01:57,340 --> 00:02:01,310
一个更简单的字符串 也就是空字符串 所以

39
00:02:01,310 --> 00:02:03,190
我们知道如果输入的字符串为空字符串时

40
00:02:03,190 --> 00:02:06,970
这个回文过程的返回值应该为逻辑真 也就是说空字符串

41
00:02:06,970 --> 00:02:09,580
属于回文 如果输入字符串不是空字符串

42
00:02:09,580 --> 00:02:12,610
好了 解决这种输入的一种方法是

43
00:02:12,610 --> 00:02:15,150
观察字符串的第一个字符 然后观察

44
00:02:15,150 --> 00:02:17,970
字符串的最后一个字符 如果这两个字符相等

45
00:02:17,970 --> 00:02:21,630
好 那它就可能是一个回文 要肯定这个字符串是回文的话

46
00:02:21,630 --> 00:02:24,430
这个单词余下的中间部分也应该是回文

47
00:02:24,430 --> 00:02:28,190
所以这就是我们解决

48
00:02:28,190 --> 00:02:31,980
测试一个字符串是否为回文的几个小步骤 我们的

49
00:02:31,980 --> 00:02:36,050
递归情况将会是测试第一个和最后一个

50
00:02:36,050 --> 00:02:39,570
字符串中的字符 判断它们是否相等 如果

51
00:02:39,570 --> 00:02:42,840
我们执行到递归情况 我们会测试第一个和最后一个

52
00:02:42,840 --> 00:02:45,770
字符串中的字母 如果它们的值不匹配 我们就知道这个字符串

53
00:02:45,770 --> 00:02:48,520
不是回文 也就是我们的结果应该为

54
00:02:48,520 --> 00:02:51,100
逻辑假 如果它们的值匹配的话 我们还没完成任务 我们需要

55
00:02:51,100 --> 00:02:54,190
测试字符串的剩余部分 也就是说 我们需要

56
00:02:54,190 --> 00:02:58,130
测试字符串的中间部分 测试它是否属于回文

57
00:02:58,130 --> 00:03:02,500
因为我们可以递归地定义这个过程 我们要记住

58
00:03:02,500 --> 00:03:06,080
我们在定义 is_palindrom 这个过程 但是我们可以这样执行字符串中间部分的测试

59
00:03:06,080 --> 00:03:08,750
假设我们已经定义了 is_palindrome 这个过程 为了测试

60
00:03:08,750 --> 00:03:11,260
字符串的中间部分是否为回文 我们可以调用

61
00:03:11,260 --> 00:03:13,610
我们正在定义的这个过程 这就好像我们

62
00:03:13,610 --> 00:03:16,530
可以使用 factorial 过程来定义针对更小数字的 factorial 过程

63
00:03:16,530 --> 00:03:20,210
在这个例子中 我们正在定义一个

64
00:03:20,210 --> 00:03:23,160
处理更小规模字符串的判断回文过程 希望我给出的提示足够你

65
00:03:23,160 --> 00:03:24,380
开始 is_palindrome 过程的定义任务 接下来看看你是否

66
00:03:24,380 --> 00:03:28,160
定义 is_palindrom 过程的代码 记住

67
00:03:28,160 --> 00:03:31,820
我们可以拆分过程为两种情况 如果输入的是空字符串 我们知道

68
00:03:31,820 --> 00:03:34,530
它肯定是一个回文 如果字符串不为空

69
00:03:34,530 --> 00:03:35,970
好 我们需要观察第一个字符和

70
00:03:35,970 --> 00:03:38,990
最后一个字符 如果它们的值匹配的话 我们还要

71
00:03:38,990 --> 00:03:40,670
继续观察字符串的中间部分
