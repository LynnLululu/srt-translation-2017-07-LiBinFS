1
00:00:00,250 --> 00:00:03,600
所以 它们的答案是最后两个

2
00:00:03,600 --> 00:00:06,350
两者都需要遍历整个循环 与索引元素数量相当

3
00:00:06,350 --> 00:00:09,360
的循环次数 在关键词在索引中

4
00:00:09,360 --> 00:00:12,990
不存在的情况下 这个判定将永远是假 然后

5
00:00:12,990 --> 00:00:15,350
会一直走到循环的最后 并返回 None

6
00:00:15,350 --> 00:00:18,642
关键词在添加的最后一项的情况下 我们仍然将

7
00:00:18,642 --> 00:00:21,810
经过元素数量的次数的循环 但是在最后一次循环中

8
00:00:21,810 --> 00:00:25,470
我们会找到匹配项 并返回该元素

9
00:00:25,470 --> 00:00:27,300
在所有这些分析中的一个假设是

10
00:00:27,300 --> 00:00:29,950
通过循环所需的时间不取决于传递的

11
00:00:29,950 --> 00:00:32,960
实际关键词 这是在假设 这个相等的

12
00:00:32,960 --> 00:00:38,000
比较判断 不论元素和关键词是什么 都消耗

13
00:00:38,000 --> 00:00:40,830
相同的时间 也就是说关键词是什么

14
00:00:40,830 --> 00:00:43,190
没有关系 比较判断消耗的时间是

15
00:00:43,190 --> 00:00:46,370
相同的 而事实证明 对于字符串和 Python 来说就是这样的

16
00:00:46,370 --> 00:00:50,110
情况 我们可以非常迅速地做出这些字符串的比较

17
00:00:50,110 --> 00:00:53,420
因为字符串是不可变的 这意味着 我们并不需要

18
00:00:53,420 --> 00:00:56,180
比较字符串中的所有字符来比较两个字符串

19
00:00:56,180 --> 00:00:59,370
字符串的双等于运算可以以这样的方式来完成

20
00:00:59,370 --> 00:01:01,660
它并不需要看整个字符串 它知道这些

21
00:01:01,660 --> 00:01:03,850
字符串是以不同的字符串创建而成的

22
00:01:03,850 --> 00:01:05,349
也就是说它们是不同的字符串 或者

23
00:01:05,349 --> 00:01:08,760
如果他们是以同一个字符串创建的 它们就是相同的字符串 所以

24
00:01:08,760 --> 00:01:11,750
这就是为什么我们说 循环中的所有

25
00:01:11,750 --> 00:01:15,330
其他操作都消耗相同的时间 它们不取决于输入的

26
00:01:15,330 --> 00:01:18,840
大小 这些都是非常快的操作

27
00:01:18,840 --> 00:01:21,770
在理解时间方面重要的是 我们遍历

28
00:01:21,770 --> 00:01:24,860
该索引的次数 如果你继续参与课程

29
00:01:24,860 --> 00:01:28,290
我希望你会继续 我们将了解如何以更正式

30
00:01:28,290 --> 00:01:31,120
的方式分析算法 现在我们的目标是培养

31
00:01:31,120 --> 00:01:34,640
一种直觉 对于这种直觉需要重点了解的是

32
00:01:34,640 --> 00:01:37,310
运行时间取决于我们经过这个循环的次数

33
00:01:37,310 --> 00:01:40,520
我们在循环中做的一切都是固定的时间

34
00:01:40,520 --> 00:01:42,890
它不受元素大小的影响

