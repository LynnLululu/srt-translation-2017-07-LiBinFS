1
00:00:00,070 --> 00:00:01,859
那么 让我们试着定义一个具有

2
00:00:01,859 --> 00:00:04,780
这些特性的哈希函数 我们想要

3
00:00:04,780 --> 00:00:07,510
哈希函数做的是 传入一个字符串

4
00:00:07,510 --> 00:00:12,010
我们称这个哈希函数为 hash_string

5
00:00:12,010 --> 00:00:16,604
然后它会产生0 到 b-1 之间的数字

6
00:00:16,604 --> 00:00:21,010
作为输出 所以 我们还需要另一个输入

7
00:00:21,010 --> 00:00:23,180
到我们的 hash_string 也就是哈希表

8
00:00:23,180 --> 00:00:25,290
的大小 所以这会是第二个

9
00:00:25,290 --> 00:00:28,880
输入 哈希表的大小

10
00:00:28,880 --> 00:00:31,670
桶的数量 我们还没有看到的

11
00:00:31,670 --> 00:00:33,540
在这个函数里需要的 是一种

12
00:00:33,540 --> 00:00:37,920
将字符串转换成数字的方法 Python 提供了一个

13
00:00:37,920 --> 00:00:41,030
操作可以做到这一点 叫做 ord 是

14
00:00:41,030 --> 00:00:43,410
ordinal (序数) 的缩写 ord 需要的是输入

15
00:00:43,410 --> 00:00:46,920
一个单字母的字符串 输出

16
00:00:46,920 --> 00:00:50,350
一个数字 而字符串和数字之间的实际映射

17
00:00:50,350 --> 00:00:52,300
不是那么重要 我们只是想要

18
00:00:52,300 --> 00:00:53,830
不同的字符串映射到

19
00:00:53,830 --> 00:00:57,400
不同的数字 还有另一个操作

20
00:00:57,400 --> 00:01:00,156
与之相反 其可以将一个数字

21
00:01:00,156 --> 00:01:04,690
输出为对应的单字母字符串

22
00:01:04,690 --> 00:01:07,810
这两个函数拥有相反的

23
00:01:07,810 --> 00:01:10,510
特性 如果我们取

24
00:01:10,510 --> 00:01:15,415
对应于一个序号的字符 该序号对应于任何的

25
00:01:15,415 --> 00:01:21,530
单字母字符串 我们称之为 α 我们得到的结果将与

26
00:01:21,530 --> 00:01:23,440
我们传入的 α 相同 那么 让我们

27
00:01:23,440 --> 00:01:25,970
在 Python 解释器中尝试几个例子

28
00:01:25,970 --> 00:01:30,150
看看 ord 和 chr 的工作方式 我们要打印 ord('a') 然后

29
00:01:31,560 --> 00:01:36,270
当我们运行 我们看到我们得到数字 97 如果我们尝试打印 ord('A')

30
00:01:39,510 --> 00:01:44,020
就不一样了 我们得到了 65 如果我们打印 ord('B')

31
00:01:46,940 --> 00:01:50,740
我们得到 66 所以 数字是有一种合理的顺序的

32
00:01:50,740 --> 00:01:54,810
B 比 A 要大一点 小写字母拥有

33
00:01:54,810 --> 00:01:58,210
与大写字母不同的序号 所以 如果我们尝试

34
00:01:58,210 --> 00:02:00,606
小写的 b 我们应该期望得到 98

35
00:02:01,960 --> 00:02:03,730
而且这确实是我们得到的 这些都是

36
00:02:03,730 --> 00:02:06,840
基于 ASCII 字符编码得到的数字

37
00:02:06,840 --> 00:02:09,639
实际数字是什么 对我们并不太重要

38
00:02:09,639 --> 00:02:12,010
只要我们得到了不同的字母对应不同的数字

39
00:02:12,010 --> 00:02:13,760
因此 我们就可以使用

40
00:02:13,760 --> 00:02:15,980
ord 的结果 使不同的字符串哈希值不同

41
00:02:15,980 --> 00:02:24,320
然后 来展示一下它们的相反特性 如果我们取 ord('u') 然后

42
00:02:24,320 --> 00:02:26,420
取它的 chr 值 我们就可以得回

43
00:02:28,280 --> 00:02:31,520
我们一开始的单字母字符串 u

44
00:02:31,520 --> 00:02:33,840
ord 的限制是 它只对

45
00:02:33,840 --> 00:02:37,580
单字母字符串起作用 如果它提供将任何字符串

46
00:02:37,580 --> 00:02:40,220
映射为一个数字 将对哈希表很有用

47
00:02:40,220 --> 00:02:42,910
接下来我们就来试一下 不过 它并没有做到这一点

48
00:02:42,910 --> 00:02:45,770
如果我们尝试对一个多字母字符串运行它 我们得到

49
00:02:45,770 --> 00:02:49,110
一个错误 它说 ord 期望的是一个单字母 但它

50
00:02:49,110 --> 00:02:52,070
获取了长度7的字符串 因此我们将需要

51
00:02:52,070 --> 00:02:55,810
只对单字母字符串使用 ord 所以使用ord 我们有

52
00:02:55,810 --> 00:02:59,850
一种方法将字符串转换为数字 将单字母字符串

53
00:02:59,850 --> 00:03:03,060
转换为数字 我们需要我们的哈希函数拥有的第二个特性是

54
00:03:03,060 --> 00:03:07,900
是我们的输出数字始终在 0 和 b-1 之间 我们需要它在

55
00:03:07,900 --> 00:03:10,520
这个范围内 因为我们将用它来索引

56
00:03:10,520 --> 00:03:13,240
这个列表 找到该字符串所属的桶

