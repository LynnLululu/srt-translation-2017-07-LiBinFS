1
00:00:00,210 --> 00:00:04,236
这是我要推荐的我最喜欢的顺序 首先我们先写一个

2
00:00:04,236 --> 00:00:08,460
daysInMonth 的雏形 它将输入一个年份和月份 并总是返回 30

3
00:00:08,460 --> 00:00:12,663
这当然不正确 之后我们将修改 nextDay 函数

4
00:00:12,663 --> 00:00:16,300
来使用这个雏形 然后立刻对它进行测试

5
00:00:16,300 --> 00:00:19,550
截止到此时 我们还没有真正改变之前获得的输出

6
00:00:19,550 --> 00:00:22,800
如果测试是正确的话 但是我们现在正在重新构建代码

7
00:00:22,800 --> 00:00:26,760
我们所要做的就是改进 daysInMonth 函数 然后我们将会得到正确的答案

8
00:00:26,760 --> 00:00:31,674
下一件要做的 是将 daysInMonth 在不考虑闰年的情况下修改正确

9
00:00:31,674 --> 00:00:35,020
我会把考虑闰年尽量推迟 因为闰年真的很烦

10
00:00:35,020 --> 00:00:38,530
但是这种复杂性也只是偶尔出现

11
00:00:38,530 --> 00:00:41,910
我们可以先得到一个非常接近正确的答案 并且知道

12
00:00:41,910 --> 00:00:45,174
我们已经获得了所有的代码结构 一切都在合适的位置

13
00:00:45,174 --> 00:00:48,882
所以我将推迟考虑闰年 然后我认为再次测试是个好主意

14
00:00:48,882 --> 00:00:52,858
因此我们将在第五步再次测试 在这里

15
00:00:52,858 --> 00:00:57,648
用 daysInMonth 来测试当然是完全没有问题的 但是我认为一个更简单的方法是

16
00:00:57,648 --> 00:01:02,236
用 nextDay 因为我们只需要再运行一次 和步骤3一样的测试就可以了

17
00:01:02,236 --> 00:01:06,541
现在我们就到了需要考虑闰年的时候了

18
00:01:06,541 --> 00:01:10,427
所以接下来要解决闰年的问题 我将先写一个

19
00:01:10,427 --> 00:01:15,097
辅助函数 isLeapYear 这是步骤6 之后我将对它进行单独测试

20
00:01:15,098 --> 00:01:18,532
这是另一个你可能会有异议的步骤 会想也可以用

21
00:01:18,532 --> 00:01:22,375
daysInMonth 或者 nextDay 来测试 但是 isLeapYear 有点特别

22
00:01:22,375 --> 00:01:26,108
把它拿来单独测试会更加有意义 好的 完成这个之后

23
00:01:26,108 --> 00:01:30,195
就有了一个完整的解决方案了 可以再分开测试它一下

24
00:01:30,195 --> 00:01:33,749
但是我现在对我剩下的代码很有信心 我将直接跳到

25
00:01:33,749 --> 00:01:37,450
步骤 K 来运行所有的测试用例 这就是我推荐的顺序了

26
00:01:37,450 --> 00:01:41,720
但是当然还有很多其他顺序也是对的 其中一个就是

27
00:01:41,720 --> 00:01:44,570
你可以把闰年的程序放到最开始去

28
00:01:44,570 --> 00:01:48,048
如果你喜欢闰年 也不想把它推迟到后面再做的话

29
00:01:48,048 --> 00:01:51,956
那就可以先单独把它弄完 另一件可能会发生的事是

30
00:01:51,956 --> 00:01:55,176
用了 daysInMonth 来测试 而不是 nextDay 这也是完全没问题的

31
00:01:55,176 --> 00:01:58,395
所以对于这个问题 这里有很多正确的答案

32
00:01:58,395 --> 00:02:02,348
这些所有正确答案共同的特点是 不停地写一点点代码

33
00:02:02,348 --> 00:02:06,022
然后再对其进行独立测试 而不是写一大堆代码

34
00:02:06,022 --> 00:02:09,514
而不能对它进行测试 在开发者要学习的事情中

35
00:02:09,514 --> 00:02:12,938
最重要的一件是 思考结构化代码的方法

36
00:02:12,938 --> 00:02:16,708
去组织你构建代码的方法 这样你就能够在写的时候 进行有意义的测试

37
00:02:16,708 --> 00:02:20,304
并且看着代码一步步越来越接近你需要的正确答案

38
00:02:20,304 --> 00:02:24,132
当你对作为一个程序员更加有自信的时候 你可能会跳过一些步骤

39
00:02:24,132 --> 00:02:27,540
但是我问这个问题的部分动机是

40
00:02:27,540 --> 00:02:31,115
当我自己做这个问题的时候 我的解答出现了一个 bug 这是因为

41
00:02:31,115 --> 00:02:35,278
我没有足够仔细地按照步骤来做 当我试着运行所有测试时

42
00:02:35,278 --> 00:02:39,440
它们都失败了 比起按照步骤做 调试多花了很多时间

43
00:02:39,440 --> 00:02:43,470
当你在解答时 我要鼓励你去做的是

44
00:02:43,470 --> 00:02:47,550
作为你解答的一部分 写代码来运行所有测试 之后我期盼的是

45
00:02:47,550 --> 00:02:51,937
如果你进行了所有步骤 也都测试完了 当你最后到达步骤 K 时

46
00:02:51,937 --> 00:02:56,215
把程序在所有测试用例上运行时 它将神奇般地一次就运行正确了

47
00:02:56,215 --> 00:03:00,014
当然这并不是什么魔法 这只是系统地以及小心地

48
00:03:00,014 --> 00:03:01,453
解决问题的自然结果
