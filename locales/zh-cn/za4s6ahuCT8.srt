1
00:00:00,000 --> 00:00:01,500
鉴于 hash_string 问题

2
00:00:01,500 --> 00:00:04,000
我们将确定下面的哪些说法是正确的

3
00:00:04,000 --> 00:00:06,000
让我们一个一个地看这些说法

4
00:00:06,000 --> 00:00:11,000
第一个说法是查询哈希表里没有的关键字

5
00:00:11,000 --> 00:00:15,000
所需要进行字符串比对次数可能小于

6
00:00:15,000 --> 00:00:17,000
查询哈希表内含有的关键字的次数

7
00:00:17,000 --> 00:00:19,000
实际上 这确实是正确的说法

8
00:00:19,000 --> 00:00:21,000
我们举个例子来说明

9
00:00:21,000 --> 00:00:26,000
在这里 我给出一个有3个桶和3个关键字的字典实例

10
00:00:26,000 --> 00:00:29,000
我没有给出哈希函数的值是因为对于这个例子来说它们无关紧要

11
00:00:29,000 --> 00:00:31,000
当我们搜索 "Batman" 时就是说法1为真的情况 

12
00:00:31,000 --> 00:00:33,000
哈希函数找到0号桶

13
00:00:33,000 --> 00:00:37,000
然后我们不得不将关键字分别和 "Andy" "is"比对 最后再和 "Batman" 比对

14
00:00:37,000 --> 00:00:39,000
所以这需要3次字符串比较

15
00:00:39,000 --> 00:00:44,000
而当我们搜索 "Irvin" 时 我们找到2号桶
16
00:00:44,000 --> 00:00:47,000
2号桶是空的 所以一次比较也不用做

17
00:00:47,000 --> 00:00:50,000
这就是那个查询哈希表内的数据所需要的比对次数确实大于

18
00:00:50,000 --> 00:00:55,000
查询不在哈希表里的数据需要的比对次数的例子

19
00:00:55,000 --> 00:00:59,000
第二个说法是我们可以预测当我们增加哈希桶的数量时 

20
00:00:59,000 --> 00:01:02,000
搜索大多数关键字的时间将会减少

21
00:01:02,000 --> 00:01:04,000
在有一个好的哈希函数的情况下 这是正确的

22
00:01:04,000 --> 00:01:07,000
假设我们有一个只包含两个桶的哈希表

23
00:01:07,000 --> 00:01:12,000
如果我们有一个好的哈希函数 那么在每个桶里的关键词的数量是一样的

24
00:01:12,000 --> 00:01:15,000
为了搜索哈希表里的某个关键词

25
00:01:15,000 --> 00:01:18,000
进行比较平均次数应该是桶的大小的一半

26
00:01:18,000 --> 00:01:23,000
如果我们将桶的数量增加一倍 平均搜索时间明显减少

27
00:01:23,000 --> 00:01:26,000
在有一个好的哈希函数的情况下 搜索时间减少地更多

28
00:01:26,000 --> 00:01:29,000
第三个说法是在哈希表中 桶的数量总是越多越好

29
00:01:29,000 --> 00:01:31,000
从使用"总是"这个词语可以看出 

30
00:01:31,000 --> 00:01:34,000
这是一个相当绝对的说法

31
00:01:34,000 --> 00:01:36,500
但正是因为"总是"这个词语导致这个说法是错误的

32
00:01:36,500 --> 00:01:38,000
这有两个很好的原因

33
00:01:38,000 --> 00:01:41,000
第一个原因是随着桶的数量的变化

34
00:01:41,000 --> 00:01:45,000
或多或少地会改变关键字的索引位置

35
00:01:45,000 --> 00:01:48,000
这样一种情况可能发生 在两个桶的情况下 关键词的分布合理

36
00:01:48,000 --> 00:01:51,000
但是当我增加第三个桶后 

37
00:01:51,000 --> 00:01:53,000
哈希函数将所有的关键词放到新桶中

38
00:01:53,000 --> 00:01:57,000
我们仔细选择哈希函数使这种情况很少发生

39
00:01:57,000 --> 00:02:00,000
但是取决于我们正在使用的关键词 这种情况仍然有可能出现

40
00:02:00,000 --> 00:02:02,000
第二个原因是内存

41
00:02:02,000 --> 00:02:04,000
我可以有一个任意长的哈希表

42
00:02:04,000 --> 00:02:08,000
但是它将会占用大量的空间 尤其是表里只有少量关键词的时候

43
00:02:08,000 --> 00:02:13,000
靠谱的哈希表实现力争得到

44
00:02:13,000 --> 00:02:16,000
哈表内桶的数量和关键词数量的比值

45
00:02:16,000 --> 00:02:19,000
这样 随着哈希表内关键词的数量的增加和减少

46
00:02:19,000 --> 00:02:22,000
相应地增加桶的数量

47
00:02:22,000 --> 00:02:25,000
第四个说法是 在哈希表中搜索一个关键字的时间

48
00:02:25,000 --> 00:02:30,000
总是小于在线性表(正如第四单元用过的)中搜索所花费的时间

49
00:02:30,000 --> 00:02:33,000
问题是 搜索时间总是小于

50
00:02:33,000 --> 00:02:37,000
搜索我们以前使用过的列表所需要时间?

51
00:02:37,000 --> 00:02:40,000
正如你怀疑的那样 这个说法是错误的

52
00:02:40,000 --> 00:02:43,000
我们将给出一个哈希表实例来证明

53
00:02:43,000 --> 00:02:47,000
假设我们有一个3个关键词全部在1号桶的哈希表

54
00:02:47,000 --> 00:02:52,000
如果我想查找关键字"Batman" 我会找到1号桶

55
00:02:52,000 --> 00:02:56,000
接着遍历桶中的每个关键字直到我找到"Batman"为止

56
00:02:56,000 --> 00:03:01,000
这本质和我们不做任何哈希变换 

57
00:03:01,000 --> 00:03:03,000
从头开始一个一个遍历每个关键字来查找"Batman"

58
00:03:03,000 --> 00:03:06,000
的普通列表是一样的
