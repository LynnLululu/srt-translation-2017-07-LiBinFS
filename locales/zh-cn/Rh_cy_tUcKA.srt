1
00:00:00,000 --> 00:00:02,000
我们有很多方法能解决这一问题

2
00:00:02,000 --> 00:00:05,000
这是一种方法：我们将定义 is_friend 这一过程

3
00:00:05,000 --> 00:00:09,000
首先 我们要看这个名字是否以 D 开头

4
00:00:09,000 --> 00:00:12,354
如果是 那么结果为真 我们就立刻返回 True

5
00:00:12,354 --> 00:00:14,446
如果不是 我们就要继续

6
00:00:14,446 --> 00:00:18,000
我们要看这个名字是否以字母 N 开头

7
00:00:18,000 --> 00:00:20,277
如果是 我们就返回 True

8
00:00:20,277 --> 00:00:23,462
如果我们到这里 这个名字的首字母既不是 D 也不是 N

9
00:00:23,462 --> 00:00:25,523
这意味着我们应返回 False

10
00:00:25,523 --> 00:00:28,000
我们来看看它是如何运行的

11
00:00:28,000 --> 00:00:31,000
我们有三个测试

12
00:00:31,000 --> 00:00:33,000
第一个以 D 开头 所以应该为真

13
00:00:33,000 --> 00:00:36,000
第二个以 N 开头 应该为真

14
00:00:36,000 --> 00:00:39,400
第三个以 F 开头 所以应该为假

15
00:00:39,400 --> 00:00:42,000
所以我们有很多方法能解决这个问题

16
00:00:42,000 --> 00:00:45,000
我们也可以在这里用一个 else

17
00:00:45,000 --> 00:00:47,000
在 else 里面用 if

18
00:00:47,000 --> 00:00:52,000
这里也可以写一个 else 然后返回假

19
00:00:52,000 --> 00:00:54,000
运行的结果是一样的

20
00:00:54,000 --> 00:00:57,000
多写了一些代码 但也体现了结构

21
00:00:57,000 --> 00:00:59,000
可能比第一种更好一些

22
00:00:59,000 --> 00:01:02,000
另外 我们也可以直接返回结果

23
00:01:02,000 --> 00:01:06,000
这就需要引入一个新的、我们还没有用过的 Python 运算符

24
00:01:06,000 --> 00:01:08,000
也就是 or 运算符

25
00:01:08,000 --> 00:01:10,000
我们可以这么做

26
00:01:10,000 --> 00:01:13,000
实际效果和我们之前很长的过程一样

27
00:01:13,000 --> 00:01:17,000
检查名字第一个字母是否是 D

28
00:01:17,000 --> 00:01:22,000
或者第一个字母是否是 N

29
00:01:22,000 --> 00:01:24,000
得出的结果是一样的

30
00:01:24,000 --> 00:01:24,500
我们已经介绍了这个新的构建 or (或)

31
00:01:24,500 --> 00:01:25,000
其左右两边的运算对象的逻辑关系是 or 
