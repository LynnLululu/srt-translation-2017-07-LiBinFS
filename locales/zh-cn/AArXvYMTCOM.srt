1
00:00:00,390 --> 00:00:02,420
那么 我们需要做什么来使查找更快呢？

2
00:00:02,420 --> 00:00:05,620
嗯 让我们想想为什么它这么慢吧

3
00:00:05,620 --> 00:00:08,630
它这么慢的原因是 我们用循环来查找

4
00:00:08,630 --> 00:00:12,130
我们按顺序遍历所有的元素并且检查

5
00:00:12,130 --> 00:00:14,470
它们是否与关键字匹配 对吧？而且我们不得不遍历

6
00:00:14,470 --> 00:00:18,550
整个索引 来查找一个条目 查找一个索引中不存在

7
00:00:18,550 --> 00:00:21,170
的关键字 为了确定它不存在 我们不得不

8
00:00:21,170 --> 00:00:25,850
遍历整个索引 这不是我们在现实生活中

9
00:00:25,850 --> 00:00:29,160
使用索引的方式 如果你要在一本书的索引中

10
00:00:29,160 --> 00:00:31,830
查找一个词 你不必将每一个条目都看一遍

11
00:00:31,830 --> 00:00:35,090
来确定这次词是否存在 你可以跳跃浏览

12
00:00:35,090 --> 00:00:37,590
你能跳跃浏览的原因是在索引中的条目都是

13
00:00:37,590 --> 00:00:41,200
分类排序的 它们按字母顺序排序 使你得知这个条目

14
00:00:41,200 --> 00:00:44,230
属于哪部分 你只需要找到对应的部分看看

15
00:00:44,230 --> 00:00:46,960
它是否存在 因此 我们可以使用

16
00:00:46,960 --> 00:00:50,930
不随意排序的索引来做到这一点 如果我们使索引保持

17
00:00:50,930 --> 00:00:54,140
分类排序 那么我们就能找到条目所属

18
00:00:54,140 --> 00:00:57,820
的位置并找到它 排序是一个非常

19
00:00:57,820 --> 00:01:01,050
有趣的问题 这些内容实际上我们不会在本课程

20
00:01:01,050 --> 00:01:04,260
讨论太多 我们要用一种不同的方式来

21
00:01:04,260 --> 00:01:06,140
操作 我们现在要做的是找到一种方法

22
00:01:06,140 --> 00:01:10,010
来找到条目应该在哪里 而实际上并不需要使

23
00:01:10,010 --> 00:01:12,330
所有条目保持排序 我们要做到的是可以

24
00:01:12,330 --> 00:01:16,200
使我们做到 给定一个关键字 将有一些函数

25
00:01:16,200 --> 00:01:18,810
告诉我们它属于哪里 我们将称之为

26
00:01:18,810 --> 00:01:23,000
哈希函数 它会告诉我们条目在哪里

27
00:01:23,000 --> 00:01:25,640
查看 所以不必遍历

28
00:01:25,640 --> 00:01:29,300
整个索引 哈希函数会告诉我们该条目

29
00:01:29,300 --> 00:01:32,520
所属位置 所以我们需要的是

30
00:01:32,520 --> 00:01:34,990
一些函数 传入一个关键字 以一个数字

31
00:01:34,990 --> 00:01:38,010
定位它 这个数字是该条目在

32
00:01:38,010 --> 00:01:41,380
索引中的位置 我们可以用

33
00:01:41,380 --> 00:01:44,070
许多不同的方式做到这一点 其中一个简单的方式是

34
00:01:44,070 --> 00:01:47,910
想想 我们知道字母表 这更像是

35
00:01:47,910 --> 00:01:51,060
书本索引的工作方式 然后我们要

36
00:01:51,060 --> 00:01:55,040
根据首字母 给每个条目一个下标 

37
00:01:55,040 --> 00:01:58,050
我们会把所有首字母相同

38
00:01:58,050 --> 00:02:01,000
的项放在相同的位置 所以 如果我们寻找

39
00:02:01,000 --> 00:02:04,700
以 U 开头的关键字 这个哈希

40
00:02:04,700 --> 00:02:06,420
会告诉我们去所有以 U 开头的词

41
00:02:06,420 --> 00:02:08,820
所在的位置寻找 然后我们就只需要

42
00:02:08,820 --> 00:02:11,490
遍历所有以 U 开头的词 那么这将使得

43
00:02:11,490 --> 00:02:13,770
我们一次查找的速度远远超过遍历

44
00:02:13,770 --> 00:02:17,490
整个索引 这并不是最好的方式 如果

45
00:02:17,490 --> 00:02:20,780
我们根据字母分好区 那么我们就会有

46
00:02:20,780 --> 00:02:23,693
一个问题 如果我们有两个首字母相同的单词 你

47
00:02:23,693 --> 00:02:27,100
通常都会有多个单词的首字母相同

48
00:02:27,100 --> 00:02:31,950
因此 不是每个位置只有一个元素

49
00:02:31,950 --> 00:02:34,960
我们将有一个列表 包括所有

50
00:02:34,960 --> 00:02:38,970
以 U 开头的单词 所以当我们查找

51
00:02:38,970 --> 00:02:42,650
udacity 我们查找 U 列表中的条目 如果

52
00:02:42,650 --> 00:02:46,010
该词未找到匹配项 那么我们就知道 udacity 不在

53
00:02:46,010 --> 00:02:48,920
索引中 这其中有很多问题 第一个问题是

54
00:02:48,920 --> 00:02:51,350
嗯 可能有不止一个词的首字母为 U

55
00:02:51,350 --> 00:02:53,780
所以我们在这里不能只有一个条目 我们需要的是

56
00:02:53,780 --> 00:02:57,120
有一整个列表的条目 我们常常称之为 桶 (bucket)

57
00:02:57,120 --> 00:02:59,340
那么 我们需要一个所有条目的桶 (bucket)

58
00:02:59,340 --> 00:03:02,990
在这个以 U 开头的位置 因此

59
00:03:02,990 --> 00:03:05,690
不像我们旧索引结构一样 只有一个

60
00:03:05,690 --> 00:03:08,180
条目 现在我们将拥有一个条目列表 而且

61
00:03:08,180 --> 00:03:10,680
现在 索引中的每个元素将是一个桶 即

62
00:03:10,680 --> 00:03:14,810
在正确的位置上的条目的列表

63
00:03:14,810 --> 00:03:17,800
这将是我们的所有首字母为 U 的

64
00:03:17,800 --> 00:03:22,320
条目的桶 而且其中将有所有不同的

65
00:03:22,320 --> 00:03:25,970
以字母 U 开头的条目 那么这样

66
00:03:25,970 --> 00:03:28,890
变的好点了 现在 对于每个查找 不必

67
00:03:28,890 --> 00:03:31,180
遍历所有索引的词汇 我们只需要

68
00:03:31,180 --> 00:03:34,482
找到正确首字母的位置 这里找到一个

69
00:03:34,482 --> 00:03:36,590
装有所有以该字母开始的词的桶  然后

70
00:03:36,590 --> 00:03:39,520
遍历这个桶 这样做还可以 但是

71
00:03:39,520 --> 00:03:43,440
这并不能真正很好地缩小规模 最好的情况 如果你

72
00:03:43,440 --> 00:03:47,540
知道的话 1000万字现在不必遍历1000万个

73
00:03:47,540 --> 00:03:50,720
条目 而是遍历1000万除以 26

74
00:03:50,720 --> 00:03:54,620
如果我们有26个字母 这并不能使

75
00:03:54,620 --> 00:03:57,940
速度快很多 它最多也就可以处理26倍

76
00:03:57,940 --> 00:04:01,760
的词 这还要假设所有的桶大小相同

77
00:04:01,760 --> 00:04:04,470
当然 如果我们根据首字母划分桶

78
00:04:04,470 --> 00:04:06,470
它们不会是相同大小 如果词

79
00:04:06,470 --> 00:04:08,890
是典型的英语单词 我们将有更多

80
00:04:08,890 --> 00:04:12,420
s 或 t 开头的单词 比起以 u 开头的单词来说

81
00:04:12,420 --> 00:04:15,590
所以 我们要解决这些两个问题 我们想要

82
00:04:15,590 --> 00:04:17,779
有更多的桶 因此 我们不打算只

83
00:04:17,779 --> 00:04:20,140
使用首字母 我们要对整个词使用一些函数

84
00:04:20,140 --> 00:04:24,020
使它告诉我们它属于什么位置 而且我们将努力

85
00:04:24,020 --> 00:04:27,640
使该函数可以相当好得分配词语

86
00:04:27,640 --> 00:04:30,460
我所描述的结构就是所谓的哈希表

87
00:04:30,460 --> 00:04:33,460
这是一种非常有用的数据结构 所以被

88
00:04:33,460 --> 00:04:37,450
内置到 Python 中 有一种叫做字典的 Python 类型 提供了

89
00:04:37,450 --> 00:04:40,270
此功能 在今天的单元结束后 我会解释

90
00:04:40,270 --> 00:04:42,190
Python 的字典是如何工作的 以及如何使用它

91
00:04:42,190 --> 00:04:45,280
我们会修改搜索引擎代码 使用字典

92
00:04:45,280 --> 00:04:48,010
代替我们构建的查找表 但在此之前

93
00:04:48,010 --> 00:04:51,080
我们要自己实现它 我们

94
00:04:51,080 --> 00:04:52,690
要确保我们了解哈希表

95
00:04:52,690 --> 00:04:54,840
的工作原理 通过自己编写所有的代码

96
00:04:54,840 --> 00:04:58,568
然后我们将切换为使用内置的 Python 格式

