1
00:00:00,000 --> 00:00:03,350
这是一个挺难的问题 我希望你们可以解决它

2
00:00:03,350 --> 00:00:05,270
有很多方法能解决这个问题

3
00:00:05,270 --> 00:00:09,000
我会先在画板上展示一种方法

4
00:00:09,000 --> 00:00:13,000
然后我们看看如何在 Python 解释器中用不同方法解决这一问题

5
00:00:13,000 --> 00:00:15,000
我将用 a、b 和 c 来指代这三个输入

6
00:00:15,000 --> 00:00:17,000
我们可以用任何符号来指代

7
00:00:17,000 --> 00:00:19,000
因为这些数字没有特别的意义

8
00:00:19,000 --> 00:00:22,000
所以我就用这三个字母好了

9
00:00:22,000 --> 00:00:26,000
所以一种方法就是使用一个长而复杂的嵌套 if 语句

10
00:00:26,000 --> 00:00:28,000
我们将使用若干个比较

11
00:00:28,000 --> 00:00:31,000
首先 我们想要检查 a 是否大于 b 

12
00:00:31,000 --> 00:00:34,000
如果 a 大于 b a 可能是最大值

13
00:00:34,000 --> 00:00:38,000
但是我们还不确定 我们还要检查 a 是否大于 c 

14
00:00:38,000 --> 00:00:40,580
所以我们需要两个 if 

15
00:00:40,580 --> 00:00:42,000
值得注意的是

16
00:00:42,000 --> 00:00:48,000
a 大于 c 这一比较是缩进在 如果 a 大于 b 里面的

17
00:00:48,000 --> 00:00:51,000
所以这只有在 a 大于 b 时才会执行

18
00:00:51,000 --> 00:00:54,000
也就是说 如果 a 大于 b 且 a 大于 c 

19
00:00:54,000 --> 00:00:57,000
a 是最大的 所以我们就返回 a 

20
00:00:57,000 --> 00:01:01,000
如果情况不是如此 现在的情况还是 a 大于 b 

21
00:01:01,000 --> 00:01:06,000
但是 a 不大于 c 也就是说 c 大于或等于 a 

22
00:01:06,000 --> 00:01:08,000
那我们就知道 c 是最大的

23
00:01:08,000 --> 00:01:11,000
因为 c 大于或等于 a 而 a 大于 b 

24
00:01:11,000 --> 00:01:13,000
所以现在我们就返回 c 

25
00:01:13,000 --> 00:01:18,000
当我们知道 c 大于或等于 a 

26
00:01:18,000 --> 00:01:20,410
我们也知道 a 大于 b 

27
00:01:20,410 --> 00:01:22,000
因为这个测试证明这是正确的

28
00:01:22,000 --> 00:01:24,000
所以我们知道 返回 c 是正确的

29
00:01:24,000 --> 00:01:28,000
现在 我们想要一个 else 来对应这一条件

30
00:01:28,000 --> 00:01:33,000
在这里 如果 a 大于 b 我们就执行这一块编码

31
00:01:33,000 --> 00:01:35,000
如果 a 不大于 b 

32
00:01:35,000 --> 00:01:40,000
这就意味着：b 大于或等于 a 

33
00:01:40,000 --> 00:01:46,000
在这种情况下 我们想检查 b 是否大于 c 

34
00:01:46,000 --> 00:01:51,000
所以我们需要另一个 if 我将使用 如果 b 大于 c 

35
00:01:51,000 --> 00:01:53,000
现在我们知道 b 大于 c 

36
00:01:53,000 --> 00:01:56,000
并且 b 大于或等于 a 因为我们已经到了 else 这里

37
00:01:56,000 --> 00:01:58,000
所以我们就可以返回 b 

38
00:01:58,000 --> 00:02:02,000
如果情况不是如此 我们知道 b 大于或等于 a 

39
00:02:02,000 --> 00:02:05,000
且 c 大于或等于 b 

40
00:02:05,000 --> 00:02:07,000
而 b 又大于或等于 a 

41
00:02:07,000 --> 00:02:09,360
所以这就意味着 c 是最大的

42
00:02:09,360 --> 00:02:11,000
我们应该返回 c 

43
00:02:11,000 --> 00:02:13,700
在这里我们有一个 最大值 的定义

44
00:02:13,700 --> 00:02:15,000
这挺复杂的

45
00:02:15,000 --> 00:02:19,000
我们用了3个不同的 if 语句

46
00:02:19,000 --> 00:02:23,000
主要的一个从比较 a 和 b 开始

47
00:02:23,000 --> 00:02:25,720
在那之内 我们比较 a 和 c 

48
00:02:25,720 --> 00:02:27,550
然后我们用了一个 else 

49
00:02:27,550 --> 00:02:29,830
在 else 里面 我们比较 b 和 c 

50
00:02:29,830 --> 00:02:32,440
当我们使用了很多嵌套的 if 表达式

51
00:02:32,440 --> 00:02:34,750
当然 我们还可以用更多

52
00:02:34,750 --> 00:02:37,000
但是这已经够混乱了

53
00:02:37,000 --> 00:02:39,610
我们就应该思考 有没有一种更清楚的方式

54
00:02:39,610 --> 00:02:42,000
让代码少一些 简单一些

55
00:02:42,000 --> 00:02:44,000
且更容易理解 如果更容易理解

56
00:02:44,000 --> 00:02:47,000
那么也就更容易正确地写出来

57
00:02:47,000 --> 00:02:50,000
所以一个更简单的方式就是使用 较大值 程序

58
00:02:50,000 --> 00:02:52,000
我们在本单元前面一部分定义过

59
00:02:52,000 --> 00:02:57,000
如果你还记得 我们是这么定义 较大值 的：

60
00:02:57,000 --> 00:03:01,000
较大值 需要两个输入 并对其进行比较：如果 a 大于 b 

61
00:03:01,000 --> 00:03:03,000
那么就返回 a 

62
00:03:03,000 --> 00:03:07,000
如果不是 那么 b 是较大值——或者至少两个值相等

63
00:03:07,000 --> 00:03:09,000
所以我们就返回 b 

64
00:03:09,000 --> 00:03:13,000
既然我们已经定义了 较大值 

65
00:03:13,000 --> 00:03:15,000
那么我们就能用一种简单得多的方法来定义 最大值 

66
00:03:15,000 --> 00:03:17,000
我们不需要所有这些 if 

67
00:03:17,000 --> 00:03:19,000
我们只需要使用 较大值 两次

68
00:03:19,000 --> 00:03:22,000
所以如果我们记得我们有 最大值 这个程序

69
00:03:22,000 --> 00:03:25,000
我们可以这样来看 最大值 

70
00:03:25,000 --> 00:03:27,000
我们有三个输入

71
00:03:27,000 --> 00:03:30,000
程序要输出这三个中的最大值

72
00:03:30,000 --> 00:03:33,000
我们已经有 较大值 这个程序了

73
00:03:33,000 --> 00:03:36,000
所以我们可以用 较大值 来比较两个数字

74
00:03:36,000 --> 00:03:40,000
如果我们将 a 和 b 输入 较大值 

75
00:03:40,000 --> 00:03:43,000
这里的输出将会是 a 和 b 中较大的一个

76
00:03:43,000 --> 00:03:47,000
要知道三个数字中的最大值——我们就要将这个数字

77
00:03:47,000 --> 00:03:51,000
和 c 相比较 所以这个 较大值 程序的输入

78
00:03:51,000 --> 00:03:54,000
将是以 a 和 b 为输入的 较大值 的结果

79
00:03:54,000 --> 00:03:56,000
以及输入 c 

80
00:03:56,000 --> 00:03:59,000
而输出就会是这三个数字中最大的一个

81
00:03:59,000 --> 00:04:02,000
这里调用了 较大值 两次

82
00:04:02,000 --> 00:04:05,000
第一次调用的输入是 a 和 b 

83
00:04:05,000 --> 00:04:08,000
我们希望第一次调用的输出将是下一次调用的输入

84
00:04:08,000 --> 00:04:10,000
我们可以用编码做到这一点

85
00:04:10,000 --> 00:04:12,000
我们可以直接返回结果

86
00:04:12,000 --> 00:04:17,000
这里的结果将是 较大值 的结果

87
00:04:17,000 --> 00:04:20,000
我指的是后一个 较大值 

88
00:04:20,000 --> 00:04:22,000
当我们复合程序

89
00:04:22,000 --> 00:04:25,260
我们要先考虑实际上最后调用的函数

90
00:04:25,260 --> 00:04:29,000
因为那个函数需要其它函数的输入

91
00:04:29,000 --> 00:04:32,870
所以 这次调用 较大值 需要两个输入

92
00:04:32,870 --> 00:04:38,000
我们已经有了以 a 和 b 为输入的 较大值 的结果

93
00:04:38,000 --> 00:04:40,000
也就是在这儿

94
00:04:40,000 --> 00:04:42,000
输入 a 和 b 输出结果

95
00:04:42,000 --> 00:04:48,000
这一结果是一个输入 第二个输入是 c 

96
00:04:48,000 --> 00:04:50,000
用这种方法来写 最大值 就简单多了

97
00:04:50,000 --> 00:04:52,230
它利用一个我们已经定义的过程

98
00:04:52,230 --> 00:04:55,000
可以找出两个输入中的较大值

99
00:04:55,000 --> 00:04:58,000
现在我们想要找出三个输入中的 最大值 

100
00:04:58,000 --> 00:05:00,260
其实还有一种更简单的方法

101
00:05:00,260 --> 00:05:02,920
那就是使用一个内置操作符

102
00:05:02,920 --> 00:05:06,000
我们可以直接使用 max 这个内置操作符

103
00:05:06,000 --> 00:05:09,210
来实现 较大值 直接返回 (a b c) 中的 最大值 

104
00:05:09,210 --> 00:05:11,470
如果我们知道这个内置操作符 max 

105
00:05:11,470 --> 00:05:14,000
我们就完全不需要找 最大值 了

106
00:05:14,000 --> 00:05:15,870
我们可以就使用内置的 max 

107
00:05:15,870 --> 00:05:19,400
重要的是 我们意识到 我们自己可以定义过程

108
00:05:19,400 --> 00:05:22,000
事实上 我们现在学过的已经足够多了

109
00:05:22,000 --> 00:05:25,000
Python 里的每一个内置程序

110
00:05:25,000 --> 00:05:27,000
你们都可以自己定义

111
00:05:27,000 --> 00:05:28,410
更重要的是 利用你们现在所学过的

112
00:05:30,920 --> 00:05:32,350
你们可以写出任何电脑程序

113
00:05:32,350 --> 00:05:34,180
就用我们所学过的知识

114
00:05:34,180 --> 00:05:36,230
这是很令人震惊的

115
00:05:36,230 --> 00:05:38,000
我真这么认为

116
00:05:38,000 --> 00:05:40,560
所有能被任何机器进行机械计算的东西

117
00:05:40,560 --> 00:05:44,000
都能用一个程序来描述

118
00:05:44,000 --> 00:05:46,000
而编这样一个程序只需用到我们现在所学过的知识

119
00:05:46,000 --> 00:05:48,000
你们所需要的就是过程 简单的算法

120
00:05:48,000 --> 00:05:51,000
加上比较 和 if 语句

121
00:05:51,000 --> 00:05:53,000
这是很了不起的

122
00:05:53,000 --> 00:05:57,000
阿兰·图灵早在20世纪30年代就证明了这一点

123
00:05:57,000 --> 00:06:00,000
阿兰·图灵很可能是最重要的计算机科学家

124
00:06:00,000 --> 00:06:03,350
在上世纪30年代 他开发出了一个计算机的抽象模型

125
00:06:03,350 --> 00:06:05,000
我们现在称其为 图灵机 

126
00:06:05,000 --> 00:06:08,210
并且他证明了 那台机器 只要很少的简单操作

127
00:06:08,210 --> 00:06:10,000
就可以模拟其它任何机器

128
00:06:10,000 --> 00:06:13,000
我要指出 阿兰·图灵做这些是早在上世纪30年代

129
00:06:13,000 --> 00:06:16,000
当时还没有我们现在这样的计算机

130
00:06:16,000 --> 00:06:18,550
在30年代 人们认为

131
00:06:18,550 --> 00:06:20,460
计算机就是一个能做计算的人

132
00:06:20,460 --> 00:06:23,000
他们以一种机械的方式做计算

133
00:06:23,000 --> 00:06:26,000
根据你可能在小学里学过的过程

134
00:06:26,000 --> 00:06:29,000
来做长除法或长算法

135
00:06:29,000 --> 00:06:32,000
阿兰·图灵证明了 一个非常简单的模型

136
00:06:32,000 --> 00:06:35,000
就足以实现一台机械计算机所有能做的事情

137
00:06:35,000 --> 00:06:38,000
不论那是一个计算员还是一台现代计算机

138
00:06:38,000 --> 00:06:41,000
他们通过电子运行 正如我们今天所想的一样

139
00:06:41,000 --> 00:06:43,000
在二战后 他在布莱切利公园工作

140
00:06:43,000 --> 00:06:45,000
这是英国的司令部

141
00:06:45,000 --> 00:06:48,000
英国人在这里破解纳粹的密码

142
00:06:48,000 --> 00:06:51,000
阿兰·图灵领头 破解了 Enigma 密码

143
00:06:51,000 --> 00:06:57,000
Enigma 是纳粹使用得最为广泛的密码

144
00:06:57,000 --> 00:07:01,000
阿兰·图灵建造了能够用于破解 Enigma 密码的机器

145
00:07:01,000 --> 00:07:03,000
这些机器有点儿像计算机

146
00:07:03,000 --> 00:07:05,000
它们做很多很多的计算

147
00:07:05,000 --> 00:07:09,000
这些机器和我们所认为的计算机之间的一大区别

148
00:07:09,000 --> 00:07:11,000
就是这些机器不是可编程的

149
00:07:11,000 --> 00:07:13,000
它们只能用于一个特定的任务

150
00:07:13,000 --> 00:07:17,000
就是做某种计算 以破解用 Enigma 加密的信息

151
00:07:17,000 --> 00:07:19,000
这是非常有用的

152
00:07:19,000 --> 00:07:21,000
对二战产生了巨大影响

153
00:07:21,000 --> 00:07:25,000
但它们不是计算机 因为它们不能被编程来做其它事情

154
00:07:25,000 --> 00:07:28,000
这门课程不会涉及图灵机的理论

155
00:07:28,000 --> 00:07:31,000
但是之后的一门课会讲到 我希望你们会选那门课

156
00:07:31,000 --> 00:07:35,780
现在要强调的是 只需要很少的简单操作

157
00:07:35,780 --> 00:07:39,000
你就可以随心所欲地模拟其它任何操作

158
00:07:39,000 --> 00:07:42,330
你们已经学过了算法 学过了比较

159
00:07:42,330 --> 00:07:45,000
学过了如何定义和调用过程

160
00:07:45,000 --> 00:07:48,000
也学过了如何使用 if 来做决定

161
00:07:48,000 --> 00:07:51,000
这就足够模拟任何其它计算机能做的事情了

162
00:07:51,000 --> 00:07:55,000
所以你们可以写出任何可能的计算机程序

163
00:07:55,000 --> 00:07:59,000
我们可以现在就结束这门课程 根据你们现在所掌握的

164
00:07:59,000 --> 00:08:01,000
你们可以构建任何运算

165
00:08:01,000 --> 00:08:03,000
但是我们并不会现在就结束这门课程

166
00:08:03,000 --> 00:08:05,610
因为 尽管理论上

167
00:08:05,610 --> 00:08:07,000
你们可以利用现在所学过的简单知识来构建任何运算

168
00:08:09,670 --> 00:08:12,000
但那却不会是构建运算的最佳方法

169
00:08:12,000 --> 00:08:16,000
我们还能使用一些更有力的结构

170
00:08:16,000 --> 00:08:19,840
也就是说 用更少的编码 或用一种更为优雅的方式

171
00:08:19,840 --> 00:08:22,000
我们可以写出我们想要的运算

172
00:08:22,000 --> 00:08:25,000
我们还有很多要学习 练习运用这些知识

173
00:08:25,000 --> 00:08:27,000
来定义更有趣的程序

174
00:08:27,000 --> 00:08:29,320
但理论上

175
00:08:29,320 --> 00:08:31,000
写任何运算所需要的所有知识

176
00:08:31,000 --> 00:08:35,000
你们都已经学过了 也就是我们所学过的这些结构

