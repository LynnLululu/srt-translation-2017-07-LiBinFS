1
00:00:00,550 --> 00:00:03,450
欢迎来到第五单元 本单元的主要议题

2
00:00:03,450 --> 00:00:06,890
是试图理解程序运行的成本

3
00:00:06,890 --> 00:00:09,260
到目前为止 我们还没有真正担心过这个 我们一直很开心地

4
00:00:09,260 --> 00:00:12,590
写代码 如果我们得到正确的结果 就是一件

5
00:00:12,590 --> 00:00:16,640
伟大的事情 但一旦我们开始做更大的项目

6
00:00:16,640 --> 00:00:19,750
想要程序做更多的事情 在更大的输入中运行 我们

7
00:00:19,750 --> 00:00:22,380
不得不开始思考我们项目运行的成本

8
00:00:22,380 --> 00:00:26,290
评估一次程序运行成本的问题

9
00:00:26,290 --> 00:00:28,570
是计算机科学中一个非常重要的问题

10
00:00:28,570 --> 00:00:31,490
在某种意义上 这是最根本的问题之一 很多人

11
00:00:31,490 --> 00:00:33,930
整个职业生涯都是在研究这个 这个

12
00:00:33,930 --> 00:00:38,060
问题称为算法分析 我还没有解释过

13
00:00:38,060 --> 00:00:41,220
什么是算法 但是你实际已经写下很多了

14
00:00:41,220 --> 00:00:44,370
所以 算法是 总是能够完成的程序

15
00:00:44,370 --> 00:00:48,920
一个程序只是一个精心定义的步骤序列

16
00:00:48,920 --> 00:00:52,410
它必须被足够精确地定义 以保证可以被机械地运行

17
00:00:52,410 --> 00:00:54,080
所以一个程序必须是

18
00:00:54,080 --> 00:00:58,550
没有思想地被执行 而我们对程序

19
00:00:58,550 --> 00:01:01,140
最感兴趣的是它们可以由计算机来执行

20
00:01:01,140 --> 00:01:03,300
使之成为程序的重要部分是

21
00:01:03,300 --> 00:01:06,320
步骤是非常精确地定义 并且不需要任何思想

22
00:01:06,320 --> 00:01:09,950
去执行 要成为一种算法 它必须总是能完成

23
00:01:11,150 --> 00:01:14,170
而且我们已经指出这是一个非常困难的问题

24
00:01:14,170 --> 00:01:17,900
去找出一个程序是否能够完成 一般来说

25
00:01:17,900 --> 00:01:21,470
是不可能回答这个问题的 但对于许多具体

26
00:01:21,470 --> 00:01:23,720
的问题 为了使一个程序成为

27
00:01:23,720 --> 00:01:26,610
算法 我们必须知道 它总是能完成 它总是

28
00:01:26,610 --> 00:01:30,150
产生正确的结果 所以一旦我们有一个算法 好 我们

29
00:01:30,150 --> 00:01:32,870
知道我们有一个明确的步骤顺序 所以我们可以推理

30
00:01:32,870 --> 00:01:36,660
在输入任何东西时会发生什么 我们知道我们

31
00:01:36,660 --> 00:01:39,720
总是会完成 总是产生正确的结果 于是我们

32
00:01:39,720 --> 00:01:42,920
可以考虑一下 在某些输入的情况下 算法的成本是多少

33
00:01:42,920 --> 00:01:46,810
那么我们应该怎么考虑成本

34
00:01:46,810 --> 00:01:49,280
计算机科学家考虑成本的方式

35
00:01:49,280 --> 00:01:52,860
与大多数人考虑成本的方式大不相同

36
00:01:52,860 --> 00:01:56,080
所以 如果你常常考虑成本 如果

37
00:01:56,080 --> 00:01:58,340
你已经有了一个特定的对象 比方说 你有

38
00:01:58,340 --> 00:02:02,447
一辆很酷的车 假设这是一辆

39
00:02:02,447 --> 00:02:05,246
酷车 虽然它完全不像

40
00:02:05,246 --> 00:02:08,365
它有一个与之相关的成本

41
00:02:08,365 --> 00:02:11,470
比方说 这是一辆 $ 25,000 的车 你有一些

42
00:02:11,470 --> 00:02:14,040
其他车 所以 你有一辆车 它有一个

43
00:02:14,040 --> 00:02:16,880
特定的成本 这就是你得到这辆车的成本

44
00:02:16,880 --> 00:02:20,365
你有另一辆汽车 比较小 绿色的 然后

45
00:02:20,365 --> 00:02:24,480
比方说 汽车的成本是 $ 10,000 而当我们想

46
00:02:24,480 --> 00:02:27,340
通常物品的成本时 我们有非常具体的事情

47
00:02:27,340 --> 00:02:29,290
他们有具体的成本 而我们知道

48
00:02:29,290 --> 00:02:33,550
红车花费 $ 25,000 绿车花费 $ 10,000

49
00:02:33,550 --> 00:02:35,420
红车成本比绿车多 我们

50
00:02:35,420 --> 00:02:38,190
只需要比较这些成本 所以 当我们

51
00:02:38,190 --> 00:02:41,790
考虑算法的成本 我们

52
00:02:41,790 --> 00:02:45,680
心里没有一个具体的评估方法

53
00:02:45,680 --> 00:02:47,730
我们想要了解 根据输入 算法的成本是多少

54
00:02:47,730 --> 00:02:50,830
我们有两种不同的算法

55
00:02:50,830 --> 00:02:54,060
比如说这是算法一 我们有一个

56
00:02:54,060 --> 00:02:58,670
算法二 解决同样的问题 而且两者

57
00:02:58,670 --> 00:03:03,410
都是需要输入和产生输出的算法

58
00:03:05,420 --> 00:03:09,660
如果我们要决定哪种算法比较好 我们

59
00:03:09,660 --> 00:03:11,980
没有一种可以计算算法具体成本的方式

60
00:03:11,980 --> 00:03:13,760
像对刚才的汽车做的一样 我们可以说

61
00:03:13,760 --> 00:03:16,230
红车比绿车成本高 算法的成本取决于

62
00:03:16,230 --> 00:03:18,820
我们运行时的实际输入 所以可能

63
00:03:18,820 --> 00:03:22,640
对于某些输入 算法一比较快

64
00:03:22,640 --> 00:03:27,350
对于其他输入 算法二又比较快 那我就应该标注

65
00:03:27,350 --> 00:03:30,920
算法二 所以 我们需要了解的是

66
00:03:30,920 --> 00:03:35,380
根据这个输入 运行算法的成本是多少

67
00:03:35,380 --> 00:03:38,450
我们不想针对每一个特定的输入 如果我们

68
00:03:38,450 --> 00:03:40,450
不得不这样做 那我们还不如

69
00:03:40,450 --> 00:03:42,930
就运行 输入 看看它的成本是多少

70
00:03:42,930 --> 00:03:45,510
我们想要做的是能够预测 而不是

71
00:03:45,510 --> 00:03:49,430
在每种输入下实际运行 通常情况下

72
00:03:49,430 --> 00:03:52,120
具体的输入并不会影响太多 最主要的

73
00:03:52,120 --> 00:03:55,940
影响因素是输入的规模

74
00:03:55,940 --> 00:03:59,434
不过不总是这种情况 我们将看到输入的其他属性

75
00:03:59,434 --> 00:04:01,760
但我们谈论的主要方式

76
00:04:01,760 --> 00:04:04,340
是根据输入规模的计算机科学成本

77
00:04:04,340 --> 00:04:07,660
对于输入规模来说 输入增大 

78
00:04:07,660 --> 00:04:11,420
如何评估程序成本的增加？

79
00:04:11,420 --> 00:04:14,920
成本最终总是归结为金钱 而当它归结为金钱

80
00:04:14,920 --> 00:04:17,410
那么 当我们运行算法的时候

81
00:04:17,410 --> 00:04:21,110
什么是需要花钱的？花钱的主要方面就是

82
00:04:21,110 --> 00:04:24,090
花费时间 如果我们可以更快

83
00:04:24,090 --> 00:04:27,370
获得一个答案 好 我们花了更少的时间 而我们

84
00:04:27,370 --> 00:04:30,570
还可以按时间租用计算机来运算

85
00:04:30,570 --> 00:04:33,980
现在有大量的云计算服务 会给你一个处理器

86
00:04:33,980 --> 00:04:36,360
有特定功率和一定量的时间

87
00:04:36,360 --> 00:04:39,600
每小时花费特定的钱 所以时间就是金钱

88
00:04:39,600 --> 00:04:43,060
因此 我们并不需要把我们的成本估算为钱

89
00:04:43,060 --> 00:04:46,570
因为我们并不一定知道我们将要花费多少

90
00:04:46,570 --> 00:04:48,970
但是 如果我们可以把它理解为运行需要的时间

91
00:04:48,970 --> 00:04:52,380
会让我们对成本有一个良好的认知 另一个

92
00:04:52,380 --> 00:04:56,000
主要成本往往是内存 所以 如果我们知道

93
00:04:56,000 --> 00:04:58,630
运行算法需要的特定内存 那么

94
00:04:58,630 --> 00:05:01,140
它就能告诉我们需要的计算机的规模

95
00:05:01,140 --> 00:05:04,320
以及那将有多贵 所以 我们通常不会

96
00:05:04,320 --> 00:05:07,570
以美元来讨论成本 当我们分析算法时

97
00:05:07,570 --> 00:05:11,880
我们以时间和内存来讨论成本 但在现实中

98
00:05:11,880 --> 00:05:14,160
这些东西最终也是以美元计算的

99
00:05:14,160 --> 00:05:18,080
所以 我们将主要专注于测量时间

100
00:05:18,080 --> 00:05:20,630
而且对于运行算法来说 时间通常是最重要的成本

101
00:05:20,630 --> 00:05:24,210
内存往往是另一个考虑方面
